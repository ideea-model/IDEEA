[{"path":"https://ideea-model.github.io/IDEEA/articles/about.html","id":"founding-members","dir":"Articles","previous_headings":"","what":"Founding Members","title":"IDEEA team and community","text":"Dr Balachandra Patil, Chief Research Scientist, Department Management Studies, Indian Institute Science, Bengaluru Dr Joyashree Roy, Founder Director, South Southeast Asia Multidisciplinary Research Network Transforming Societies Global South (SMARTS), Asian Institute Technology, Bangkok, Representing Global Change Program, Jadavpur University, Kolkata Parthaa Bosu, Principal, Domain Functional Advisory LLP (DFAG) Lead Advisor – India, Environmental Defense Fund (EDF) Dr Oleg Lugovoy, Lead Senior Economist, EDF","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/about.html","id":"ideea-team","dir":"Articles","previous_headings":"","what":"IDEEA team","title":"IDEEA team and community","text":"[ToDo: arrange alphabetical order? position/roles] Jadavpur University Joyashree Roy, Founder Director, South Southeast Asia Multidisciplinary Research Network Transforming Societies Global South (SMARTS), Asian Institute Technology, Bangkok, Represents Global Change Program, Jadavpur University Anupam Debsarkar, Professor, Department Civil Environmental Engineering Sourish Chatterjee Arijit Mukherjee Piku Sen Prantika Sarkar Biswajit Thakur Biswanath Roy Indian Institute Science Abhishek Das Manjunath M Samridh Sharma Varun Jyothiprakash Balachandra Patil EDF Parthaa Bosu, Principal, Domain Functional Advisory LLP (DFAG) Lead Advisor Lavanya Padhi, Advisor, Program Coordinator Oleg Lugovoy, Lead Senior Economist","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/about.html","id":"reviewers","dir":"Articles","previous_headings":"","what":"Reviewers","title":"IDEEA team and community","text":"Dr Tarun Sharma, Assistant Professor, Indian Institute Technology, Roorkee, Uttarakhand Mitavachan Hiremath, Co-founder Director, Centre Sustainability (SusPoT), Bengaluru","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/about.html","id":"list-of-projectsstudies","dir":"Articles","previous_headings":"","what":"List of projects/studies","title":"IDEEA team and community","text":"Link main website","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/calendars.html","id":"time-resolution","dir":"Articles","previous_headings":"","what":"Time resolution","title":"Time resoluton","text":"Sub-annual time resolution set via calendar object, specifies levels nested time-frames (‘ANNUAL’, ‘MONTH’, ‘DAY’, ‘HOUR’, etc. depending modeling goals decided level details). structure modeled sub-annual time resolution assigned timetable data.frame columns named used time-frames, well ‘slice’ (refers lowest level ‘time-slices’ unique names, e.g. ‘d001_h15’ indicating 1st day year 15th hour day), ‘share’ column (share time-frame year), ‘weight’ (weight time-frame year, used sampled calendars). time-table define calendar object, also describes hierarchy time-frames sets sequence time-slices. model object (described ) must calendar object time-frames time-slices used model. However, scenarios can solved subset time-slices, defined another calendar object sub-set time-slices. define calendar subset 1 day per month 24 hours per day. Therefore, total number time-slices subset 12 days * 24 hours = 288 time-slices (vs. 8760 time-slices full calendar).","code":"# create timetable with 3 levels of timeframes: ANNUAL, YDAY, HOUR timetable_d365_h24 <- energyRt::make_timetable(energyRt::tsl_levels$d365_h24) # full year timetable has 8760 time-slices (24 hours * 365 days) timetable_d365_h24 #>       ANNUAL   YDAY   HOUR    slice        share weight #>       <char> <char> <char>   <char>        <num>  <num> #>    1: ANNUAL   d001    h00 d001_h00 0.0001141553      1 #>    2: ANNUAL   d001    h01 d001_h01 0.0001141553      1 #>    3: ANNUAL   d001    h02 d001_h02 0.0001141553      1 #>    4: ANNUAL   d001    h03 d001_h03 0.0001141553      1 #>    5: ANNUAL   d001    h04 d001_h04 0.0001141553      1 #>   ---                                                   #> 8756: ANNUAL   d365    h19 d365_h19 0.0001141553      1 #> 8757: ANNUAL   d365    h20 d365_h20 0.0001141553      1 #> 8758: ANNUAL   d365    h21 d365_h21 0.0001141553      1 #> 8759: ANNUAL   d365    h22 d365_h22 0.0001141553      1 #> 8760: ANNUAL   d365    h23 d365_h23 0.0001141553      1 # create calendar object from a time-table calendar_d365_h24 <- newCalendar(   name = \"d365_h24\",   timetable = timetable_d365_h24   ) # pick days yday_sample <- 15 + c(0, as.integer(cumsum(days_in_month(1:11)))) # one day per month # pick hours hour_sample <- 0:23 # all 24 hours  timetable_subset <- timetable_d365_h24 |>   filter(YDAY %in% yday2YDAY(yday_sample)) |>   filter(HOUR %in% hour2HOUR(hour_sample)) timetable_subset #>      ANNUAL   YDAY   HOUR    slice        share weight #>      <char> <char> <char>   <char>        <num>  <num> #>   1: ANNUAL   d015    h00 d015_h00 0.0001141553      1 #>   2: ANNUAL   d015    h01 d015_h01 0.0001141553      1 #>   3: ANNUAL   d015    h02 d015_h02 0.0001141553      1 #>   4: ANNUAL   d015    h03 d015_h03 0.0001141553      1 #>   5: ANNUAL   d015    h04 d015_h04 0.0001141553      1 #>  ---                                                   #> 284: ANNUAL   d349    h19 d349_h19 0.0001141553      1 #> 285: ANNUAL   d349    h20 d349_h20 0.0001141553      1 #> 286: ANNUAL   d349    h21 d349_h21 0.0001141553      1 #> 287: ANNUAL   d349    h22 d349_h22 0.0001141553      1 #> 288: ANNUAL   d349    h23 d349_h23 0.0001141553      1 unique(timetable_subset$HOUR) #>  [1] \"h00\" \"h01\" \"h02\" \"h03\" \"h04\" \"h05\" \"h06\" \"h07\" \"h08\" \"h09\" \"h10\" \"h11\" #> [13] \"h12\" \"h13\" \"h14\" \"h15\" \"h16\" \"h17\" \"h18\" \"h19\" \"h20\" \"h21\" \"h22\" \"h23\" unique(timetable_subset$YDAY) #>  [1] \"d015\" \"d046\" \"d074\" \"d105\" \"d135\" \"d166\" \"d196\" \"d227\" \"d258\" \"d288\" #> [11] \"d319\" \"d349\" unique(timetable_subset$YDAY) |> tsl2dtm(year = 2019, tmz = \"Asia/Kolkata\") #>  [1] \"2019-01-15 IST\" \"2019-02-15 IST\" \"2019-03-15 IST\" \"2019-04-15 IST\" #>  [5] \"2019-05-15 IST\" \"2019-06-15 IST\" \"2019-07-15 IST\" \"2019-08-15 IST\" #>  [9] \"2019-09-15 IST\" \"2019-10-15 IST\" \"2019-11-15 IST\" \"2019-12-15 IST\"  SUBSET_HOURS <- nrow(timetable_subset) # total hours in the subset FRACT_YEAR <- SUBSET_HOURS / 8760 # fraction in a year print(\"Subannual time resolution:\") #> [1] \"Subannual time resolution:\" print(paste(\"   Total number of days a year:\", length(yday_sample))) #> [1] \"   Total number of days a year: 12\" print(paste(\"   Total number of hours per year:\", SUBSET_HOURS)) #> [1] \"   Total number of hours per year: 288\"  # Partial calendar partial_calendar <- newCalendar(   name = \"d365_h24_subset_1day_per_month\",   timetable = timetable_subset,   year_fraction = sum(timetable_subset$share) )"},{"path":"https://ideea-model.github.io/IDEEA/articles/calendars.html","id":"model-horizon","dir":"Articles","previous_headings":"","what":"Model horizon","title":"Time resoluton","text":"Calendars (currently) set sub-annual time-structure years.","code":"horizon_2020_2060_by_10 <- newHorizon(   name = \"Y2020_2060_by_10\",   desc = \"2020 to 2060 by 10 years\",   period = 2020:2060,   intervals = c(1, 5, rep(10, 15)),   mid_is_end = T ) horizon_2020_2060_by_10 #> An object of class \"horizon\" #> Slot \"name\": #> [1] \"Y2020_2060_by_10\" #>  #> Slot \"desc\": #> [1] \"2020 to 2060 by 10 years\" #>  #> Slot \"period\": #>  [1] 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 #> [16] 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 #> [31] 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 #>  #> Slot \"intervals\": #>    start   mid   end #>    <num> <num> <num> #> 1:  2020  2020  2020 #> 2:  2021  2025  2025 #> 3:  2026  2035  2035 #> 4:  2036  2045  2045 #> 5:  2046  2055  2055 #> 6:  2056  2060  2060  horizon_2020_2060_by_5 <- newHorizon(   name = \"Y2020_2060_by_5\",   desc = \"2020 to 2060 by 5 years\",   period = 2020:2060,   intervals = c(1, rep(5, 25)),   mid_is_end = T )  horizon_2020 <- newHorizon(   name = \"Y2020\",   desc = \"one year horizon: 2020\",   period = 2020,   intervals = c(1),   mid_is_end = T )  horizon_2030 <- newHorizon(   name = \"Y2030\",   desc = \"one year horizon: 2030\",   period = 2030,   intervals = c(1),   mid_is_end = T )  horizon_2040 <- newHorizon(   name = \"Y2040\",   desc = \"one year horizon: 2040\",   period = 2040,   intervals = c(1),   mid_is_end = T )  horizon_2050 <- newHorizon(   name = \"Y2050\",   desc = \"one year horizon: 2050\",   period = 2050,   intervals = c(1),   mid_is_end = T )  horizon_2060 <- newHorizon(   name = \"Y2060\",   desc = \"one year horizon: 2060\",   period = 2060,   intervals = c(1),   mid_is_end = T )  horizon_2070 <- newHorizon(   name = \"Y2070\",   desc = \"one year horizon: 2070\",   period = 2070,   intervals = c(1),   mid_is_end = T )"},{"path":"https://ideea-model.github.io/IDEEA/articles/ccus.html","id":"settings","dir":"Articles","previous_headings":"","what":"Settings","title":"Carbon capture, utilisation and storage","text":"goal carbon capture, utilization storage (CCS CCUS) technologies reduce carbon emissions fuels combustion industrial processes. emissions captured, transported, stored geological formations, used industrial processes. captured CO2 potentially can used enhanced oil recovery (EOR), production chemicals, fuels, materials. However, current status utilization limited main focus storage CO2 geological formations.","code":"nreg <- 5  # nreg <- 32 # alternative number of regions # region names where offshore regions (if any) associated with closest land-region: regN <- glue(\"reg{nreg}\")  # offshore regions have distinct names: regN_off <- glue(\"reg{nreg}_off\")"},{"path":"https://ideea-model.github.io/IDEEA/articles/ccus.html","id":"carbon-sink-potential","dir":"Articles","previous_headings":"","what":"Carbon sink potential","title":"Carbon capture, utilisation and storage","text":"potential geological storage varies region depends availability suitable geological formations, distance sources CO2, existing infrastructure. use estimated value [LINK] CCS storage potential saline aquifers basalt formations region. current settings, emis parameter @emis slot represents kt CO2 emissions per GWh fuel use (default, energy measured GWh IDEEA model). fuels used power plants, emissions calculated based fuel use, emission factors, combustion parameter technology class (slot @input) set 1 default.","code":"# Data on the potential of CO2 storage in geological formations # NOTE: the original data is by 5 regions, disaggregation is used for higher nreg ccs_reserve <- get_ideea_data(name = \"ccs_r5\", nreg = nreg)  # Declaration of domestic carbon sink resources # the objects is declared in `energy` document and saved in ideea_modules$energy # here we import saved objects for the requested number of regions  # A commodity to represent the storage of CO2 CO2SINK <- ideea_modules$energy[[regN]]$CO2SINK  # Permanent geological carbon storage (saline aquifers and basalt) potential RES_CO2SINK <- ideea_modules$energy[[regN]]$RES_CO2SINK    # Declaration of captured CO2 \"commodity\"  CCSCO2 <- newCommodity(   name = \"CCSCO2\",    desc = \"Captured CO2, kt\",   unit = \"kt\",    #slice = \"ANNUAL\", deprecated   timeframe = \"ANNUAL\" )  # Declaration of composite GHG GHG <- newCommodity(   name = \"GHG\",   desc = \"Greenhouse gas emissions, Mt\",   unit = \"Mt\",   agg = data.frame(     comm = c(\"CO2\", \"CCSCO2\"),     unit = \"kt\",     agg = c(1e3, -1e3)   ),   misc = list(     info = c(\"GHG is a composite commodity that aggregates CO2 and CCSCO2 with\",              \"specified weights (in @agg$agg)\")   ) )"},{"path":"https://ideea-model.github.io/IDEEA/articles/ccus.html","id":"ccs-with-fixed-capture-rate","dir":"Articles","previous_headings":"","what":"CCS with fixed capture rate","title":"Carbon capture, utilisation and storage","text":"simplest way reduce CO2 emissions power generation model adjust combustion parameter CCS capture rate. efficiency costs associated CCS must also adjusted accordingly. Bellow “upgrade” coal power plant IDEEA model dataset CCS technology.","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/ccus.html","id":"coal-power-plant-with-ccs","dir":"Articles","previous_headings":"CCS with fixed capture rate","what":"Coal power plant with CCS","title":"Carbon capture, utilisation and storage","text":"combustion parameter set (NA empty), default value used (1). simplicity, assume plant CCS 90% capture rate, 10% efficiency loss, 50% capital, fixed, variable costs increase. prototype CCS technology shown . Finally, since sequestration potential also limited, can track utilization carbon storage specifying input commodity (CO2SINK) aeff slot technology. CO2SINK commodity used track amount CO2 stored geological formations. can also reduce emissions conventional pollutants (NOX, SOX, PM) percentage CO2 emissions, specified auxiliary commodities efficiency slots @aux @aeff.  CO2SINK used, commodity ’s resource must added model.","code":"COA <- ideea_modules$energy[[regN]]$COA ECOA_prototype <- ideea_modules$techs$ECOAULT@data$ECOAULT_2030 ECOA_prototype@input #>   comm unit group combustion #> 1  COA  GWh  <NA>         NA # no CCS ECOA_prototype@input  #>   comm unit group combustion #> 1  COA  GWh  <NA>         NA # with CCS ECOA_CCS_FX <- update(   ECOA_prototype,   name = \"ECOA_CCS_FX\",   desc = \"Coal power plant with fixed CCS\",   input = list(comm = \"COA\", combustion = 0.1, unit = \"GWh\")   )  # Efficiency, no CCS kableExtra::kable(   select(ECOA_prototype@ceff, region, year, comm, cinp2use) ) # Efficiency, with CCS (~10% loss) ECOA_CCS_FX@ceff$cinp2use <- ECOA_prototype@ceff$cinp2use * 0.9  # Costs (~50% up) ECOA_CCS_FX@invcost$invcost <- ECOA_prototype@invcost$invcost * 1.5 ECOA_CCS_FX@fixom$fixom <- ECOA_prototype@fixom$fixom * 1.5 ECOA_CCS_FX@varom$varom <- ECOA_prototype@varom$varom * 1.5  # extend the availability window of the technology on the market ECOA_CCS_FX@end$end <- 2100 # no CCS ECOA_prototype@aux #>   acomm unit #> 1   NOX   kt #> 2   SOX   kt #> 3    PM   kt ECOA_prototype@aeff |> select(acomm, comm, cinp2aout, cinp2ainp) #>   acomm comm cinp2aout cinp2ainp #> 1   SOX  COA      0.10        NA #> 2   NOX  COA      0.10        NA #> 3    PM  COA      0.03        NA  # with CCS ECOA_CCS_FX <- update(   ECOA_CCS_FX,   aux = data.frame(     acomm = c(\"NOX\", \"SOX\", \"PM\", \"CO2SINK\"),     unit = c(\"kt\", \"kt\", \"kt\", \"kt\")   ),   aeff = data.frame(     acomm = c(\"CO2SINK\", ECOA_prototype@aeff$acomm),     comm = c(\"COA\", \"COA\", \"COA\", \"COA\"),     cinp2ainp = c(COA@emis$emis * 0.9, NA, NA, NA), # 90% capture rate     cinp2aout = c(NA,  ECOA_prototype@aeff$cinp2aout * 0.1)   ),   varom = data.frame(     acomm = \"CO2SINK\",     cvarom = convert(120.1, \"USD/t\", \"cr.₹/kt\") # ~0.1 cr.₹/kt   ) )  draw(ECOA_CCS_FX)"},{"path":"https://ideea-model.github.io/IDEEA/articles/ccus.html","id":"gas-power-plant-with-ccs","dir":"Articles","previous_headings":"CCS with fixed capture rate","what":"Gas power plant with CCS","title":"Carbon capture, utilisation and storage","text":"Similarly can add CCS natural gas biomass-powered plants. Instead updating existing technology without CCS, design technology scratch demonstrate technology-building process.","code":"GAS <- ideea_modules$energy[[regN]]$GAS EGAS_prototype <- ideea_modules$techs$ENGCC$ENGCC_2030  EGAS_CCS_FX <- newTechnology(   name = \"EGAS_CCS_FX\",   desc = \"Natural gas power plant with fixed CCS\",   input = list(     comm = \"GAS\",      unit = \"GWh\",      combustion = .1 # 10% of emissions are not captured by CCS   ),   output = data.frame(     comm = \"ELC\",     unit = c(\"GWh\")   ),    aux = data.frame(     acomm = c(\"NOX\", \"SOX\", \"PM\", \"CO2SINK\", \"CO2\"),     unit = c(\"kt\", \"kt\", \"kt\", \"kt\", \"kt\")   ),   ceff = list(     cinp2use = c(EGAS_prototype@ceff$cinp2use, NA), # 62% efficiency w/o CCS     use2cact = c(NA, .9), # 10% efficiency loss with CCS     comm = c(\"GAS\", \"ELC\")   ),   aeff = data.frame(     acomm = c(\"CO2SINK\", \"NOX\", \"SOX\", \"PM\"),     comm = c(\"GAS\", rep(\"ELC\", 3)),     cinp2ainp = c(GAS@emis$emis[1], rep(NA, 3)),     cout2aout = c(NA, .01, .01, .005) # arbitrary   ),   olife = list(olife = 40),   invcost = data.frame(     invcost = 1.5 * EGAS_prototype@invcost$invcost   ),   fixom = data.frame(     fixom = 1.5 * EGAS_prototype@fixom$fixom   ),   # variable costs are assigned in the CO2SINK supply,   # here is an alternative formulation with the same effect:   # varom = data.frame(   #   acomm = \"CO2SINK\",   #   cvarom = convert(12.1, \"USD/t\", \"cr.₹/kt\") # ~0.1 cr.₹/kt   # ),   start = list(start = 2025)   # end = list(end = 2060), ) draw(EGAS_CCS_FX)"},{"path":"https://ideea-model.github.io/IDEEA/articles/ccus.html","id":"ccs-with-flexible-capture-rate","dir":"Articles","previous_headings":"","what":"CCS with flexible capture rate","title":"Carbon capture, utilisation and storage","text":"example assumes installed, CCS operated maximum removal capacity. setting probably fit decarbonization studies, cases might helpful optional use CCS technology. example, technology can designed operate lower capture rate, depending strength carbon control policy, carbon price market. following case demonstrates alternative way design CCS technology flexible capture rate. make operation rate flexible, introduce alternative fuel input (COA_CCS GAS_CCS) define group fuel inputs different capture rates (set via combistion parameter ).  “alias” commodity require new resource, ’s supply defined bounded supply original commodity via ALIAS_COA technology costs, therefore affect model’s objective, responsible supply COA0 commodity, “made” COA commodity.","code":"# Alias commodity for coal (COA) with zero emissions COA0 <- COA |>   update(     name = \"COA0\",     desc = \"Alias for COA\"   )  ALIAS_COA <- newTechnology(   name = \"ALIAS_COA\",   desc = \"Artificial technology to create an alias for COA commodity\",   input = list(     comm = \"COA\",     unit = \"GWh\",     combustion = 0   ),   output = data.frame(     comm = \"COA0\",     unit = \"GWh\"   ),    cap2act = 1e12, # capable to convert GWh a year   capacity = list(stock = 1), # pre-defined capacity to reduce the model dimension   end = list(end = 2000) # ) draw(ALIAS_COA)"},{"path":"https://ideea-model.github.io/IDEEA/articles/ccus.html","id":"coal-power-plant-with-flexible-ccs","dir":"Articles","previous_headings":"CCS with flexible capture rate","what":"Coal power plant with flexible CCS","title":"Carbon capture, utilisation and storage","text":"key difference flexible CCS technology vs. fixed described introduction group parameter input ceff slots. group parameter used define group commodities different capture rates. ceff slot used define efficiency loss alternative fuel used (cinp2ginp) share commodity group define maximum capture rate (share.).  technology designed operate 0% 90% capture rate instead fixed 90% fixed rate example.","code":"ECOA_CCS_FL <- ECOA_CCS_FX |>   update(     name = \"ECOA_CCS_FL\",     desc = \"Coal power plant with flexible CCS\",     input = list(       comm = c(\"COA\", \"COA0\"),       unit = c(\"GWh\", \"GWh\"),       group = c(\"i\", \"i\"), # any group name       combustion = c(1, 0) # 10% of emissions are not captured by CCS     ),     geff = list(       group = \"i\",       ginp2use = ECOA_prototype@ceff$cinp2use[1]     ),     ceff = list(       comm = c(\"COA\", \"COA0\"),       cinp2ginp = c(1, .9), # efficiency loss when COA is used       share.up = c(1, .9) # max share of each commodity in the group     ),     # auxiliary inputs/outputs does not require adjustment for CCS     # since it is defined by CCS utilization (COA vs COA0)     aeff = data.frame(       acomm = c(\"CO2SINK\", ECOA_prototype@aeff$acomm),       comm = c(\"COA0\", \"COA\", \"COA\", \"COA\"),       cinp2ainp = c(COA@emis$emis, NA, NA, NA), # 90% capture rate       cinp2aout = c(NA,  ECOA_prototype@aeff$cinp2aout)     )   )  draw(ECOA_CCS_FL)"},{"path":"https://ideea-model.github.io/IDEEA/articles/ccus.html","id":"gas-power-plant-with-flexible-ccs","dir":"Articles","previous_headings":"CCS with flexible capture rate","what":"Gas power plant with flexible CCS","title":"Carbon capture, utilisation and storage","text":"approach can applied gas technology.","code":"GAS0 <- GAS |>   update(     name = \"GAS0\",     desc = \"Alias for GAS\"   )  ALIAS_GAS <- newTechnology(   name = \"ALIAS_GAS\",   desc = \"Artificial technology to create an alias for GAS commodity\",   input = list(     comm = \"GAS\",     unit = \"GWh\",     combustion = 0   ),   output = data.frame(     comm = \"GAS0\",     unit = \"GWh\"   ),    cap2act = 1e12, # capable to convert GWh a year   capacity = list(stock = 1), # pre-defined capacity to reduce the model dimension   end = list(end = 2000) # ) draw(ALIAS_GAS) EGAS_CCS_FL <- EGAS_CCS_FX |>   update(     name = \"EGAS_CCS_FL\",     desc = \"Gas power plant with flexible CCS\",     input = list(       comm = c(\"GAS\", \"GAS0\"),       unit = c(\"GWh\", \"GWh\"),       group = c(\"i\", \"i\"), # any group name       combustion = c(1, 0) # 10% of emissions are not captured by CCS     ),     geff = list(       group = \"i\",       ginp2use = EGAS_prototype@ceff$cinp2use[1]     ),     ceff = list(       comm = c(\"GAS\", \"GAS0\"),       cinp2ginp = c(1, .9), # efficiency loss when COA is used       share.up = c(1, .9) # max share of each commodity in the group     ),     aeff = data.frame(       acomm = c(\"CO2SINK\", EGAS_prototype@aeff$acomm),       comm = c(\"GAS\", \"GAS\", \"GAS\", \"GAS\"),       cinp2ainp = c(GAS@emis$emis, NA, NA, NA), # 90% capture rate       cinp2aout = c(NA,  EGAS_prototype@aeff$cinp2aout)     )   )  draw(EGAS_CCS_FL)"},{"path":"https://ideea-model.github.io/IDEEA/articles/ccus.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Carbon capture, utilisation and storage","text":"Carbon Capture, Utilization Storage (CCUS) Policy Framework Deployment Mechanism India Utilization Storage (CCUS)https://www.niti.gov./sites/default/files/2022-11/CCUS-Report.pdf","code":""},{"path":[]},{"path":"https://ideea-model.github.io/IDEEA/articles/data.html","id":"merra-2","dir":"Articles","previous_headings":"Weather data and capacity factors","what":"MERRA-2","title":"IDEEA datasets","text":"sample MERRA-2 dataset, next step acquire weather data MERRA-2 dataset, time-series every location (cell) used estimate capacity factors wind solar generators hours. use merra2ools package streamline process. weather data available 1980 2020. example sample locations 2019, embedded IDEEA R-package. years available download IDEEA’s Zenodo repository, can attached using ideea_extra() function.","code":"ideea_sf <- get_ideea_map(nreg = 32, offshore = T, islands = T)  ideea_locid <- get_locid(ideea_sf) n_locid <- length(ideea_locid)  ideea_locid_sf <- get_merra2_grid(type = \"poly\", locid = ideea_locid) |>   select(locid) |>   left_join(merra2ools::mean_cf) |>   st_make_valid()  # rename variables for consistency names(ideea_locid_sf) <- str_replace(names(ideea_locid_sf), \"waf\", \"wcf_\") |>   str_replace(\"saf\", \"scf\") names(ideea_locid_sf)  if (F) {   # the following files will be saved in 'ideea_extra' folder   # ideea_locid   save(ideea_locid, file = ideea_extra(subdir = \"merra2\",                                         filename = \"ideea_locid.RData\"))   # ideea_locid_sf   save(ideea_locid_sf,         file = ideea_extra(subdir = \"merra2\", filename = \"ideea_locid_sf.RData\")) } ggplot() +   geom_sf(data = ideea_sf, fill = alpha(\"grey\", .5), color = \"darkgrey\") +   geom_sf(data = ideea_locid_sf, fill = NA, color = \"red\") +   labs(title = glue(\"MERRA-2 grid, {n_locid} cells (locations) in total\")) +   theme_bw() d <- pivot_longer(ideea_locid_sf, cols = wcf_50m:scf_td,                    names_to = \"tech_type\", values_to = \"mean_cf\") |>    select(locid, tech_type, mean_cf, geometry) |> st_as_sf()  ggplot() +   geom_sf(aes(fill = mean_cf), data = d, color = NA) +   geom_sf(data = ideea_sf, fill = NA, color = alpha(\"black\", .25)) +   facet_wrap(~tech_type) +   scale_fill_viridis_c(option = \"H\") +   # labs(title = glue(\"MERRA-2 grid, {n_locid} cells (locations) in total\")) +   theme_bw() overwrite <- FALSE for (wyear in seq(2020, 1981, -1)) {   fname <- ideea_extra(\"merra2\", glue(\"merra_raw_{wyear}.fst\")) # file to save   # fpath <- ideea_extra(\"merra2\", fname) # file name with path   if (file.exists(fname) & !overwrite) {     message(\"File already exists: \\n     \", fname)     next   }   merra <- get_merra2_subset(     locid = ideea_locid,      from = fDate(wyear, 01, 01, 0),      to = fDate(wyear, 12, 31, 23),     tz = \"Asia/Kolkata\"     )   # merra <- merra |> select(UTC, locid, W10M, W50M, SWGDN, ALBEDO)   message(\"Saving 'raw' data: \", fname)   fst::write_fst(merra, path = fname, compress = 100)   cat(\"File size:\", {file.size(fname) |> gdata::humanReadable()}, \"\\n\" }"},{"path":[]},{"path":"https://ideea-model.github.io/IDEEA/articles/data.html","id":"global-wind-atlas-gwa","dir":"Articles","previous_headings":"Weather data and capacity factors > Wind sites","what":"Global Wind Atlas (GWA)","title":"IDEEA datasets","text":"","code":"library(terra) library(globalwindatlas)  gwa_set_dir(ideea_extra(\"gwa\")) gwa_get_dir() gwa_tif <- gwa_get_wind_cf(\"IND\", IEC = 2) # wind-class #2  ## plot  gwa_rast <- rast(gwa_tif) plot(gwa_rast, main = \"Wind capacity factors (GWA)\")"},{"path":"https://ideea-model.github.io/IDEEA/articles/data.html","id":"grouping-locations-by-capacity-factor","dir":"Articles","previous_headings":"Weather data and capacity factors > Wind sites > Global Wind Atlas (GWA)","what":"Grouping locations by capacity factor","title":"IDEEA datasets","text":"","code":"for (nreg in c(5, 32)) {   ob_name <- glue(\"gwa_iec2_r{nreg}_sf\")   fname <- ideea_extra(\"gwa\", \"{ob_name}.RData\") |> glue()   if (file.exists(fname)) next   ob <- gwa_group_locations(     gwa_tif = gwa_tif,      gis_sf = get_ideea_map(nreg = nreg, offshore = T, islands = T,                             aggregate = T, rename = F),     aggregate_tif = 0,      drop_crumps = 100,     simplify = 0.001,     buffer = 0,     int = seq(0, 1, by = .1),      verbose = T   )   assign(ob_name, ob); rm(ob)   message(\"Saving \", fname)   save(list = ob_name, file = fname)   rm(fname) }  ggplot() +   geom_sf(color = \"grey30\", fill = \"grey\", data = ideea_sf) +   geom_sf(aes(fill = eq), color = NA, data = gwa_iec2_r5_sf) +   scale_fill_viridis_d(option = \"H\", direction = 1, name = \"CF\") +   theme_bw() +   labs(title = \"Wind capacity factors by level, source: Global Wind Atlas (GWA)\") # ggsave(\"gwa_iec2_sf.png\", path = ideea_extra(\"gwa\", check = F),  #        height = 5, width = 5, scale = 1.5)"},{"path":"https://ideea-model.github.io/IDEEA/articles/data.html","id":"select-locations-with-high-wind-potential","dir":"Articles","previous_headings":"Weather data and capacity factors > Wind sites","what":"Select locations with high wind potential","title":"IDEEA datasets","text":"","code":"# parameters: win_gwa_cf_min <- 0.2 # set lowest capacity factor (GWA) win_merra_cf_min <- 0.2 # set lowest capacity factor (MERRA2/merra2ools) win_onshore_MW_km2 <- 4 # maximum MW per km2 for onshore wind (assumption) win_offshore_MW_km2 <- 4 # maximum MW per km2 for offshore wind (assumption)  for (nreg in c(5, 32)) {   ob_name <- glue(\"locid_win_r{nreg}_sf\")   fname <- ideea_extra(\"merra2\", \"{ob_name}.RData\") |> glue()   gwa_ob_name <- glue(\"gwa_iec2_r{nreg}_sf\")      ob <- ideea_locid_sf |> # MERRA grid with average CFs (no regions)     select(-starts_with(\"scf_\")) |> # drop solar cf-data     st_make_valid() |>     st_intersection( # find an intersection between GWA and MERRA sf-objects       filter(         # drop low-potential sites, based on both GWA and MERRA         get(gwa_ob_name), # GWA sf object for n-region case         int >= win_gwa_cf_min # GWA group (see above)         ),       dimensions = c(\"polygon\")       ) |>     filter(       wcf_100m >= win_merra_cf_min # MERRA     ) |>     st_make_valid() |>     mutate(       # estimate surface area of each geometry and maximum potential in MW       area = units::set_units(st_area(geometry), \"km^2\"),       MW_max = as.numeric(         round(           if_else(             offshore, # or us grepl(\"off\", reg_off),              win_offshore_MW_km2 * area, # area-based estimate, max onshore MW             win_onshore_MW_km2 * area # area-based estimate, max offshore MW             ),            0)         ),       .before = \"geometry\"     )   assign(ob_name, ob); rm(ob)   message(\"Saving \", fname)   save(list = ob_name, file = fname)   rm(fname)   }"},{"path":"https://ideea-model.github.io/IDEEA/articles/data.html","id":"cluster-locations","dir":"Articles","previous_headings":"Weather data and capacity factors > Wind sites","what":"Cluster locations","title":"IDEEA datasets","text":"","code":"# make a sample of capacity factors time-series for clustering merra <- fst::read_fst(ideea_extra(\"merra2\", \"merra_raw_2019.fst\"),                         as.data.table = TRUE)   # estimate capacity factors at different hub-heights merra_wind <-  merra |>    # fPOA() |> # solar (POA)   fWindCF(50, return_name = \"wcf_50m\") |> # wind   fWindCF(100, return_name = \"wcf_100m\") |>   fWindCF(150, return_name = \"wcf_150m\") |>   select(\"UTC\", \"locid\", starts_with(\"wcf_\"))  # cluster locations based on  for (nreg in c(5, 32)) { # for (nreg in c(32)) {      regN <- glue(\"reg{nreg}\")    regN_off <- glue(\"reg{nreg}_off\")    ob_name <- glue(\"locid_win_cl_r{nreg}\")   ob_sf_name <- glue(\"{ob_name}_sf\")   fname <- ideea_extra(\"merra2\", glue(\"locid_win_cl_r{nreg}.RData\"))   fname_sf <- str_replace(fname, \"\\\\.RData\", \"_sf\\\\.RData\")      # load sf-object (map) of filtered for wind locations with MERRA2 grid   locid_win_sf <- ideea_extra(\"merra2\", glue(\"locid_win_r{nreg}_sf.RData\")) |>     load()      # cluster locations for each group (region),   # as the results, cluster # will be assigned for each locid by region and k   # where k is the number of clusters in region, from 1:N   #       N - number of MERRA2-cells in region   ob <- cluster_locid(     merra_wind,      varname = \"wcf_100m\",      # locid_info = get(locid_win_sf),      locid_info = filter(get(locid_win_sf), int == win_merra_cf_min), # cf layer     group = regN_off,      weight = \"MW_max\",     max_loss = 0.,     # k is the number of clusters to consider. k <= N     # For large regions with many locations, the clustering process can be long.     # We can limit the options with a give sequence:     k = c(1:20, 25, 30, 40, 50, 75, 100, 150, 200, 300, 500, 1000),     plot = T,         verbose = T     )      # add 'reg{nreg}' column   if (is.null(ob[[regN]])) {     ob <- ob |>       mutate(         \"{regN}\" := str_replace_all(get(regN_off), \"_off\", \"\"), .before = 1       )   }      # rename 'ob' and save   assign(ob_name, ob); rm(ob)   message(\"Saving clustering results:\")   cat(\"    \", fname, \"\\n\")   save(list = ob_name, file = fname)    # convert cluster-table to sf-object (map), adding geometry for each cell   ob_sf <- get(locid_win_sf) |>     # select(-starts_with(\"scf_\")) |>     st_make_valid() |>     select(-MW_max) |>     right_join(get(ob_name), relationship = \"many-to-many\") |>     filter(!is.na(cluster)) |>     mutate(cluster = factor(cluster)) |>     st_as_sf()      assign(ob_sf_name, ob_sf); rm(ob_sf)   cat(\"    \", fname_sf, \"\\n\")   save(list = ob_sf_name, file = fname_sf) }"},{"path":"https://ideea-model.github.io/IDEEA/articles/data.html","id":"solar-sites","dir":"Articles","previous_headings":"Weather data and capacity factors","what":"Solar sites","title":"IDEEA datasets","text":"","code":"# parameters: # sol_cf_min <- 0.1 # set lowest capacity factor (MERRA2/merra2ools) sol_onshore_MW_km2 <- 80 # assumption (see info), maximum MW per km2 sol_offshore_MW_km2 <- 10 # assumption (see info), maximum MW per km2  for (nreg in c(5, 32)) {      ob_name <- glue(\"locid_sol_r{nreg}_sf\")   fname <- ideea_extra(\"merra2\", \"{ob_name}.RData\") |> glue()    ob <- ideea_locid_sf |> # MERRA grid with average CFs (no regions)     select(-starts_with(\"wcf_\")) |> # drop solar cf-data     st_make_valid() |>     st_intersection(       get_ideea_map(nreg, offshore = T, islands = T, rename = F),       dimensions = c(\"polygon\")     ) |>     st_make_valid() |>     mutate(       # estimate surface area of each geometry and maximum potential in MW       area = units::set_units(st_area(geometry), \"km^2\"),       MW_max = as.numeric(         round(           if_else(             offshore, # or us grepl(\"off\", reg_off),              sol_offshore_MW_km2 * area, # area-based estimate, max onshore MW             sol_onshore_MW_km2 * area # area-based estimate, max offshore MW             ),            0)         ),       .before = \"geometry\"     )   assign(ob_name, ob); rm(ob)   message(\"Saving \", fname)   save(list = ob_name, file = fname)   rm(fname)   }"},{"path":"https://ideea-model.github.io/IDEEA/articles/data.html","id":"cluster-locations-1","dir":"Articles","previous_headings":"Weather data and capacity factors > Solar sites","what":"Cluster locations","title":"IDEEA datasets","text":"","code":"# make a sample of capacity factors time-series for clustering merra <- fst::read_fst(ideea_extra(\"merra2\", \"merra_raw_2019.fst\")) |>   as.data.table()  # estimate capacity factors at different PV-tracking systems by location merra_solar <- merra |>    fPOA(array.type = c(\"fh\", \"fl\",                        # \"th\", \"tv\", # rarely used & similar to other types                       \"tl\", \"td\")) |> # solar (Plain of Array irradiance)   mutate(     # simplified version of capacity factors,      # assuming pick of output when POA >= 1000 Watt/m^2     scf_fh = round(POA.fh / 1e3, 3),     scf_fl = round(POA.fl / 1e3, 3),     # scf_th = round(POA.th / 1e3, 3),     # scf_tv = round(POA.tv / 1e3, 3),     scf_tl = round(POA.tl / 1e3, 3),     scf_td = round(POA.td / 1e3, 3)   ) |>   mutate(     # curtail cf > 1 (when POA > 1kW/m^2)     scf_fh = if_else(scf_fh > 1, 1, scf_fh),     scf_fl = if_else(scf_fl > 1, 1, scf_fl),     # scf_th = if_else(scf_th > 1, 1, scf_th),     # scf_tv = if_else(scf_tv > 1, 1, scf_tv),     scf_tl = if_else(scf_tl > 1, 1, scf_tl),     scf_td = if_else(scf_td > 1, 1, scf_td)   ) |>   select(locid, UTC, starts_with(\"scf_\"))  summary(merra_solar) merra_solar  # locid_sol_sf <- ideea_locid_sf |> #   st_make_valid() |> #   st_intersection(st_make_valid(ideea_sf)) |> #   st_make_valid() |> #   mutate( #     area = units::set_units(st_area(geometry), \"km^2\"), #     offshore = if_else(grepl(\"off\", reg_off), T, F), #     MW_max = as.numeric(round(if_else( #       offshore, #       sol_offshore_MW_km2 * as.numeric(area), #       sol_onshore_MW_km2 * as.numeric(area)), 0)), #     .before = \"geometry\" #   )  # cluster locations based on temporal correlation  for (nreg in c(5, 32)) {    regN <- glue(\"reg{nreg}\")    regN_off <- glue(\"reg{nreg}_off\")    ob_name <- glue(\"locid_sol_cl_r{nreg}\")   ob_sf_name <- glue(\"{ob_name}_sf\")   fname <- ideea_extra(\"merra2\", glue(\"locid_sol_cl_r{nreg}.RData\"))   fname_sf <- str_replace(fname, \"\\\\.RData\", \"_sf\\\\.RData\")      # load sf-object (map) of filtered for solar locations with MERRA2 grid   locid_sol_sf <- ideea_extra(\"merra2\", glue(\"locid_sol_r{nreg}_sf.RData\")) |>     load()      # cluster locations by group (region),   # as the results, cluster # will be assigned for each locid by region and k   # where k is the number of clusters in region, from 1:N   #       N - number of MERRA2-cells in region   ob <- cluster_locid(     merra_solar,      varname = \"scf_tl\",      locid_info = get(locid_sol_sf),      group = regN_off,      weight = \"MW_max\",     max_loss = 0.,      # k is the number of clusters to consider. k <= N     # For large regions with many locations, the clustering process can be long.     # We can limit the options with a give sequence:     k = c(1:20, 25, 30, 40, 50, 75, 100, 150, 200, 300, 500, 1000),     plot = T,     verbose = T     )      # add 'reg{nreg}' column   if (is.null(ob[[regN]])) {     ob <- ob |>       mutate(         \"{regN}\" := str_replace_all(get(regN_off), \"_off\", \"\"), .before = 1       )   }      # rename 'ob' and save   assign(ob_name, ob); rm(ob)   message(\"Saving clustering results:\")   cat(\"    \", fname, \"\\n\")   save(list = ob_name, file = fname)    # convert cluster-table to sf-object (map), adding geometry for each cell   ob_sf <- get(locid_sol_sf) |>     # select(-starts_with(\"scf_\")) |>     st_make_valid() |>     select(-MW_max) |>     right_join(get(ob_name), relationship = \"many-to-many\") |>     filter(!is.na(cluster)) |>     mutate(cluster = factor(cluster)) |>     st_as_sf()      assign(ob_sf_name, ob_sf); rm(ob_sf)   cat(\"    \", fname_sf, \"\\n\")   save(list = ob_sf_name, file = fname_sf) }"},{"path":"https://ideea-model.github.io/IDEEA/articles/data.html","id":"getting-capacity-factors","dir":"Articles","previous_headings":"","what":"Getting capacity factors","title":"IDEEA datasets","text":"","code":"# default tol get_ideea_cf(resource = \"sol\", nreg = 5, year = 2019) get_ideea_cf(resource = \"sol\", nreg = 32, year = 2019)  get_ideea_cf(resource = \"win\", nreg = 5, year = 2019) get_ideea_cf(resource = \"win\", nreg = 32, year = 2019)  # tol = 1% get_ideea_cf(resource = \"sol\", nreg = 5, tol = 0.01, year = 2019) get_ideea_cf(resource = \"sol\", nreg = 32, tol = 0.01, year = 2019)  get_ideea_cf(resource = \"win\", nreg = 5, tol = 0.01, year = 2019) get_ideea_cf(resource = \"win\", nreg = 32, tol = 0.01, year = 2019)"},{"path":"https://ideea-model.github.io/IDEEA/articles/data.html","id":"visualizing","dir":"Articles","previous_headings":"","what":"Visualizing","title":"IDEEA datasets","text":"Functions ideea_snapshot_cf ideea_gif_sf designed visualize capacity factors wind solar generators. first function allows plot instance potential generation given hour (timslice) particular cluster. second function creates gif-file sequence timeslices.","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/data.html","id":"solar","dir":"Articles","previous_headings":"Visualizing","what":"Solar","title":"IDEEA datasets","text":"Solar capacity factors, animated","code":"resource <- \"sol\"; cf_name <- \"scf_tl\" nreg <- 5 tol <- 0.01  # shape files ideea_sf <- get_ideea_map(nreg = nreg, offshore = T, islands = T) ideea_cl_sf <- get_ideea_cl_sf(resource = resource, tol = tol) # total clusters (maximum across regions) ideea_cl_sf$cluster |> unique() # clusters' plot plot(ideea_cl_sf[\"cluster\"]) # capacity factors x <- get_ideea_cf(resource, tol = tol, nreg = nreg, year = 2019) # plot a snapshot for a (random) slice ideea_snapshot_cf(x, ideea_cl_sf, ideea_sf, cf_name = cf_name) # create a gif-file # pull slices from partial calendar calendar_1day_per_month <-   ideea_modules$electricity$reg7_base$partial_calendar_1day_per_month slices_1day_per_month <- calendar_1day_per_month@timetable$slice  # make a gif ideea_gif_cf(x, ideea_cl_sf, ideea_sf, cf_name = cf_name,              slice = slices_1day_per_month,              fps = 5, gif.width = 864, gif.height = 864,              filename = glue(\"{resource}.gif\"))"},{"path":"https://ideea-model.github.io/IDEEA/articles/data.html","id":"wind","dir":"Articles","previous_headings":"Visualizing","what":"Wind","title":"IDEEA datasets","text":"Similarly, can visualize capacity factors wind generators. Wind capacity factors, animated tbc…","code":"resource <- \"win\"; cf_name <- \"wcf_100m\" nreg <- 5 tol <- 0.05  # ideea_sf <- get_ideea_map(nreg = nreg, offshore = T, islands = T) ideea_cl_sf <- get_ideea_cl_sf(resource = resource, tol = tol) x <- get_ideea_cf(resource, tol = tol) # plot ideea_snapshot_cf(x, ideea_cl_sf, ideea_sf, cf_name = cf_name) # gif ideea_gif_cf(x, ideea_cl_sf, ideea_sf, cf_name = cf_name,              slice = slices_1day_per_month,              fps = 5, gif.width = 864, gif.height = 864,              filename = glue(\"{resource}.gif\"))"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"configuration","dir":"Articles","previous_headings":"","what":"Configuration","title":"IDEEA: Electric power sector model","text":"Set base year (), number regions (5 32), spatial configuration. Set transmission matrix model. current matrix used 5-region model, newlines_v0X matrix used 32-region model. newlines_v01 matrix ~70 power lines, newlines_v02 ~30 power lines, newlines_v03 ~50 power lines. See details vignette(\"transmission\"). Set parameters intermittent renewable energy sources (wind solar) land use assumptions. Adjust wind solar capacity factors clustering tolerance (0 1). clustering process based correlation capacity factors MERRA2 cells (see details merra2ools. lower value gives clusters per region, larger regions’ area clusters may require higher values reduce number clusters. done yet, configure system, editing saving global options:","code":"base_year <- 2019 # the first year of the model (base year or `BY`)  # Currently '5' and '32' are available nreg <- 32 # nreg <- 5  offshore <- TRUE # should offshore regions be included islands <- TRUE # should islands be included if (nreg == 5) {   transmission_matrix <- \"current\" } else if (nreg == 32) {   # transmission_matrix <- \"newlines_v01\" # ~70 power lines   # transmission_matrix <- \"newlines_v02\" # ~50 power lines   transmission_matrix <- \"newlines_v03\" # ~30 power lines } else {   stop(\"Only 5 and 32 regions are currently implemented\") } # wind turbine hub height win_hub_height <- 100 # meters, hub height, options:  50, 100, 150   # land use for wind farms win_max_land_use <- 0.25 # % of the land area # land requirements assumption for wind farms, adjusted for maximum land use win_onshore_max_MW_km2 <- 20 * win_max_land_use # 20 MW/km2 * % of land use win_offshore_max_MW_km2 <- 5 * win_max_land_use # 5 MW/km2 * % of land use # the range is ~6-50 MW/km2 see:  # https://web.stanford.edu/group/efmh/jacobson/Articles/I/WindSpacing.pdf # https://www.nrel.gov/docs/fy09osti/45834.pdf, p.18  # land use for solar farms sol_max_land_use <- 0.1 # % of the land area sol_onshore_max_MW_km2 <- 40 * sol_max_land_use # sol_offshore_max_MW_km2: 0 * sol_max_land_use # not implemented # ~40 MW/km2 (40 GW/1000km2) # see: https://www.nrel.gov/docs/fy19osti/72399.pdf, p.18 # convert(\"ha/MW\", \"km2/MW\", 40) if (nreg == 5) {   tol_win_cl <- 0.10   tol_sol_cl <- 0.05 } else if (nreg == 32) {   tol_win_cl <- 0.05   tol_sol_cl <- 0.02 } else {   stop(\"Only 5 and 32 regions are currently implemented\") }  # region variable name to use in functions (e.g. `get_ideea_data`) regN <- paste0(\"reg\", nreg) regN_off <- paste0(regN, \"_off\") library(tidyverse) library(data.table) library(sf) library(glue) library(data.table) library(here) library(IDEEA) set_progress_bar() # show_progress_bar(F) ideea_global_options(edit = TRUE)"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"regions","dir":"Articles","previous_headings":"","what":"Regions","title":"IDEEA: Electric power sector model","text":"","code":"ideea_sf <- get_ideea_map(nreg,   offshore = offshore, islands = islands,   rename = FALSE ) plot(ideea_sf[regN_off], key.width = lcm(4.5))"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"time-resolution","dir":"Articles","previous_headings":"","what":"Time resolution","title":"IDEEA: Electric power sector model","text":"Structure sub-annual time resolution done calendar objects, specifies levels nested time-frames (‘ANNUAL’, ‘MONTH’, ‘DAY’, ‘HOUR’, etc. depending modeling goals decided level details). structure modeled sub-annual time resolution assigned timetable data.frame columns named used time-frames, well ‘slice’ (refers lowest level ‘time-slices’ unique names, e.g. ‘d001_h15’ indicating 1st day year 15th hour day), ‘share’ column (share time-frame year), ‘weight’ (weight time-frame year, used sampled calendars). time-table define calendar object, also describes hierarchy time-frames sets sequence time-slices. model object (described ) must calendar object time-frames time-slices used model. However, scenarios can solved subset time-slices, defined another calendar object sub-set time-slices. define calendar subset 1 day per month 24 hours per day. Therefore, total number time-slices subset 12 days * 24 hours = 288 time-slices (vs. 8760 time-slices full calendar).","code":"# timetable with 3 levels of timeframes: ANNUAL, YDAY, HOUR ideea_modules$calendars$calendar_d365_h24@timetable #>       ANNUAL   YDAY   HOUR    slice        share weight #>       <char> <char> <char>   <char>        <num>  <num> #>    1: ANNUAL   d001    h00 d001_h00 0.0001141553      1 #>    2: ANNUAL   d001    h01 d001_h01 0.0001141553      1 #>    3: ANNUAL   d001    h02 d001_h02 0.0001141553      1 #>    4: ANNUAL   d001    h03 d001_h03 0.0001141553      1 #>    5: ANNUAL   d001    h04 d001_h04 0.0001141553      1 #>   ---                                                   #> 8756: ANNUAL   d365    h19 d365_h19 0.0001141553      1 #> 8757: ANNUAL   d365    h20 d365_h20 0.0001141553      1 #> 8758: ANNUAL   d365    h21 d365_h21 0.0001141553      1 #> 8759: ANNUAL   d365    h22 d365_h22 0.0001141553      1 #> 8760: ANNUAL   d365    h23 d365_h23 0.0001141553      1 # the model is defined with the full calendar calendar_d365_h24 <- ideea_modules$calendars$calendar_d365_h24  # a scenario can be run with a subset of the time-slices calendar_d365_h24_subset <-   ideea_modules$calendars$calendar_d365_h24_subset_1day_per_month"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"commodities","dir":"Articles","previous_headings":"","what":"Commodities","title":"IDEEA: Electric power sector model","text":"Commodities main objects model, representing goods services traded model. Commodities can energy carriers (e.g. electricity, coal, oil, gas, biomass), emissions (e.g. CO2, NOx, SOx, PM), goods services. Commodities defined name, description, unit measure, time-frame newCommodity function. commodity-objects pre-built energy module, can loaded . Commodities specific electricity model defined . Important features commodities time-frame, limit type (slot @limtype) defines balance equation commodity. default limit type set “LO” (lower bound) meaning excess commodity allowed, deficit . options “” (upper bound) “FX” (equality).","code":"# energy ELC <- newCommodity(   name = \"ELC\",   desc = \"Electricity\",   unit = \"GWh\",   timeframe = \"HOUR\" )  # emissions CO2 <- newCommodity(   name = \"CO2\",   desc = \"Carbon emissions\",   unit = \"kt\",   timeframe = \"ANNUAL\" )  NOX <- newCommodity(   name = \"NOX\",   desc = \"Nitrogen oxide emissions NOx\",   unit = \"kt\",   timeframe = \"ANNUAL\" )  SOX <- newCommodity(   name = \"SOX\",   desc = \"Sulfur oxide emissions SOx\",   unit = \"kt\",   timeframe = \"ANNUAL\" )  PM <- newCommodity(   name = \"PM\",   desc = \"Particulate matter (particle pollution)\",   unit = \"kt\",   timeframe = \"ANNUAL\" )  REN <- newCommodity(   name = \"REN\",   desc = \"Generic renewable energy\",   unit = \"GWh\",   timeframe = \"ANNUAL\" )  # storing commodities in a repository repo_comm <- newRepository(   name = \"repo_comm\",   desc = \"Electricity & emissions commodities\" ) |>   add(ELC, CO2, NOX, SOX, PM)"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"demand-options","dir":"Articles","previous_headings":"","what":"Demand options","title":"IDEEA: Electric power sector model","text":"electricity-model, electricity considered final product, final demand can set exogenously via demand class. newDemand function creates object class demand detailed representation demanded electricity region, time-slice, year. values demand without information parameter dimension, region, time-slice, year considered default non-specified dimensions, filled-interpolation step model along missing years. Therefore enough set values base-year last year, demand expected grow linearly. load curve region India 2019 stored load_2019_MWh dataset, used example base-year demand, extrapolated model’s horizon. Hourly load region, 2019 (first six regions) demand growth set another demand-object linear growth demand every region, time-slice zero 2x base-year level 2050, 3x 2070. model horizon longer, demand can extrapolated . Alternative demand-objects can created added model interpolation/solution represent different scenarios policy options. Another ways set demand model also available. example, export objects define potential external demand levels also price electricity. sectors modeled, can also set demand electricity, e.g. transport industry modules.","code":"# call the load curve by region in 2019 from IDDEA dataset load_BY <- get_ideea_data(\"load_2019_MWh\", nreg = nreg, variable = \"MWh\") |>   mutate(GWh = MWh / 1e3) |>   select(-MWh) # rename(region = {{regN}})  # define `demand` object with the historical load curve DEMELC_BY <- newDemand(   name = \"DEMELC_BY\",   desc = \"Houlry electric demand by region, base-year level\",   commodity = \"ELC\",   unit = ELC@unit,   dem = data.frame(     region = load_BY[[regN]],     # year = load_BY$year, # assign to all years     slice = load_BY$slice,     dem = load_BY$GWh # * dem_adj   ) ) # display first 6 regions ggplot(filter(load_BY, get(regN) %in% unique(load_BY[[regN]])[1:6])) +   geom_line(aes(HOUR, GWh, color = YDAY, group = YDAY), alpha = .25) +   scale_color_viridis_c(option = \"H\", limits = c(1, 365)) +   scale_x_continuous(limits = c(0, 23)) +   # facet_wrap(~ get(regN), ncol = floor(nreg / 3), scales = \"free_y\") +   facet_wrap(~ get(regN), ncol = 2, scales = \"free_y\") +   labs(y = \"GWh\", x = \"hour\") +   theme_bw() ggsave(glue(\"load_2019_{regN}.png\"), width = 7, height = 9, path = \"tmp\") # define demand in several years, e.g. 2020, 2050, 2070, # which will be interpolated before solving the model ('interpolation' step) load_2x_2050 <-   rbind(     mutate(load_BY, year = 2020, GWh = 0.0 * GWh),     mutate(load_BY, year = 2050, GWh = 2 * GWh),     mutate(load_BY, year = 2070, GWh = 3 * GWh)   ) |>   as.data.table() load_BY #>          reg32 offshore mainland    slice            datetime MONTH  YDAY  HOUR #>         <char>   <lgcl>   <lgcl>   <char>              <POSc> <int> <int> <int> #>      1:    APY    FALSE     TRUE d001_h00 2019-01-01 00:00:00     1     1     0 #>      2:    APY    FALSE     TRUE d001_h01 2019-01-01 01:00:00     1     1     1 #>      3:    APY    FALSE     TRUE d001_h02 2019-01-01 02:00:00     1     1     2 #>      4:    APY    FALSE     TRUE d001_h03 2019-01-01 03:00:00     1     1     3 #>      5:    APY    FALSE     TRUE d001_h04 2019-01-01 04:00:00     1     1     4 #>     ---                                                                         #> 262796:     WB    FALSE     TRUE d365_h19 2019-12-31 19:00:00    12   365    19 #> 262797:     WB    FALSE     TRUE d365_h20 2019-12-31 20:00:00    12   365    20 #> 262798:     WB    FALSE     TRUE d365_h21 2019-12-31 21:00:00    12   365    21 #> 262799:     WB    FALSE     TRUE d365_h22 2019-12-31 22:00:00    12   365    22 #> 262800:     WB    FALSE     TRUE d365_h23 2019-12-31 23:00:00    12   365    23 #>              GWh #>            <num> #>      1: 5.468734 #>      2: 5.494523 #>      3: 5.349227 #>      4: 5.302847 #>      5: 5.624311 #>     ---          #> 262796: 5.776000 #> 262797: 5.580000 #> 262798: 5.278000 #> 262799: 4.845000 #> 262800: 4.554000  # define the second demand object with the load growth DEMELC_2X <- newDemand(   name = \"DEMELC_2X\",   desc = \"Additional demand growth, proportional to the current load\",   commodity = \"ELC\",   unit = ELC@unit,   dem = data.frame(     region = load_2x_2050[[regN]],     year = load_2x_2050$year,     slice = load_2x_2050$slice, # comment to assign to all hours     dem = load_2x_2050$GWh # * dem_adj   ) )"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"supply-resources","dir":"Articles","previous_headings":"","what":"Supply & resources","title":"IDEEA: Electric power sector model","text":"demand objects set final demand commodity (ELC example), supply objects define sources primary commodities (e.g. coal, gas, oil, biomass, nuclear, renewable energy sources) used production final interim products. resources used electricity model already defined energy module, can loaded . Another way introduce supply commodity model import another region outside model regions (“Rest World”, ROW). every tradable energy commodity defined import higher domestic supply price ensure domestic supply used first extend availability commodities’ supply beyond domestic resources – essencial long-term planning.","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"primary-energy","dir":"Articles","previous_headings":"Supply & resources","what":"Primary energy","title":"IDEEA: Electric power sector model","text":"","code":"# import energy supply module energy_module <- ideea_modules$energy[[regN]]  # check if the module is available for the requested number of regions if (is_empty(energy_module)) {   stop(\"ideea_modules$energy is not available for \", nreg, \" regions\") }  # define repository for energy supply and resources repo_supply <- newRepository(   name = \"repo_supply\",   desc = \"Energy supply (markets)\" ) |>   add( # import objects from energy module     # coal     energy_module$COA, # coal commodity     energy_module$SUP_COA, # coal domestic supply     energy_module$IMP_COA, # coal import     # natural gas     energy_module$GAS, # natural gas commodity     energy_module$SUP_GAS, # natural gas domestic supply     energy_module$IMP_GAS, # natural gas import     # oil     energy_module$OIL, # oil commodity     energy_module$SUP_OIL, # oil domestic supply by region     energy_module$IMP_OIL, # oil import     # biomass     energy_module$BIO, # biomass commodity     energy_module$RES_BIO, # domestic resource of biomass     # nuclear     energy_module$NUC, # nuclear fuel commodity     energy_module$IMP_NUC, # Nuclear fuel international market     # CCS storage potential (separate repo, see below)     # energy_module$CO2SINK, # stored CO2 commodity     # energy_module$RES_CO2SINK, # CO2 storage potential     #     REN, # all type of non-fuel (renewable) energy     newSupply(       name = \"RES_REN\",       commodity = \"REN\",       desc = \"An artificial commodity to represent all renewable energy\"     ),     overwrite = F # restrict duplicate objects   )  # check summary(repo_supply) #> commodity    import    supply  #>         6         4         5 names(repo_supply) #>  [1] \"COA\"     \"SUP_COA\" \"IMP_COA\" \"GAS\"     \"SUP_GAS\" \"IMP_GAS\" \"OIL\"     #>  [8] \"SUP_OIL\" \"IMP_OIL\" \"BIO\"     \"RES_BIO\" \"NUC\"     \"IMP_NUC\" \"REN\"     #> [15] \"RES_REN\""},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"land","dir":"Articles","previous_headings":"Supply & resources","what":"Land","title":"IDEEA: Electric power sector model","text":"Land resources solar wind farms defined via supply classes along solar wind technologies (see ‘Generating technologies’ section ).","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"carbon-storage","dir":"Articles","previous_headings":"Supply & resources","what":"Carbon storage","title":"IDEEA: Electric power sector model","text":"geological potential carbon storage region defined CCUS document, stored IDEEA modules.","code":"# import CCS potential from energy supply module  repo_geoccs <- newRepository(   name = \"repo_ccs\",   desc = \"Carbon storage potential by region\",   # CCS storage potential   energy_module$CO2SINK, # stored CO2 commodity   energy_module$RES_CO2SINK # CO2 storage potential ) summary(repo_geoccs) #> commodity    supply  #>         1         1  # clean-up rm(energy_module)"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"capacity-factors","dir":"Articles","previous_headings":"","what":"Capacity factors","title":"IDEEA: Electric power sector model","text":"availability renewable energy sources (solar, wind, hydro) defined capacity factors (CF) represent share potential energy can harvested given time-frame per unit generator capacity. capacity factors defined weather objects time-frame weather data (e.g. “HOUR” hourly data, “YDAY” daily data). weather data can obtained external sources (e.g. NREL, MERRA2, ERA5), saved IDEEA datasets. capacity factors can defined whole region, specific locations.","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"solar","dir":"Articles","previous_headings":"Capacity factors","what":"Solar","title":"IDEEA: Electric power sector model","text":"example implements solar capacity factors regions India, based MERRA2 dataset. capacity factors defined tilted tracking system (tl), estimated merra2ools package. Solar clusters average solar capacity factors cluster, tilted tracking system (tl)","code":"# get clustered capacity factors from `ideea_extra` dataset # if the data with requested parameters is not pre-saved,  # it will be calculated from the raw MERRA2 data using `merra2ools` package # and cashed in the `ideea_extra` dataset solar_cf <- get_ideea_cf(\"sol\", nreg = nreg, year = 2019, tol = tol_sol_cl) #> Reading capacity factors data from: #>    D:/Dropbox/projects/ideea_extra//merra2/cf_sol_r32_TOL02_d365_h24_2019.fst  #>    Maximum number of clusters per region: 8 # get map of solar clusters ideea_sol_cl_sf <- get_ideea_cl_sf(\"sol\", nreg = nreg, tol = tol_sol_cl) |>   mutate(     # create/update MW_max based on land use assumptions      MW_max = if_else(!offshore, sol_onshore_max_MW_km2 * as.numeric(area), 0)   )  # filter out offshore regions solar_cf <- solar_cf |>     filter(!grepl(\"_off$\", solar_cf[[regN_off]])) |>   unique() solar_cf$cluster |> unique() #> [1] 1 2 3 4 5 6 7 8  # maximum number of clusters: sol_clust_max <- max(solar_cf$cluster)  sol_clust_digits <- max(nchar(sol_clust_max), 2)  # add column with commodity name for the cluster's land ideea_sol_cl_sf <- ideea_sol_cl_sf |>   mutate(land_comm = name_with_cluster(     \"LAND_SOL_CL\", cluster, ndigits = sol_clust_digits))  # create repository to store solar capacity factors (weather objects) WSOL <- newRepository(name = \"Solar capacity factors\")  # create weather object for every cluster in a loop and store in the repository for (i in unique(solar_cf$cluster)) {   # select data for the cluster   x <- filter(solar_cf, cluster == i)   # create weather object   WSOL_i <- newWeather(     name = name_with_cluster(\"WSOL_CL\", i, ndigits = sol_clust_digits),     desc = name_with_cluster(       \"Solar capacity factors, tilted tracking system (tl), cluster \", i     ),     region = unique(x[[regN]]),     timeframe = \"HOUR\",     weather = data.frame(       region = x[[regN]],       slice = x$slice,       # year = NA # all years       wval = x$scf_tl     )   )   # add weather object to the repository   WSOL <- add(WSOL, WSOL_i)   # clean-up   rm(x, WSOL_i) }  # check the repository summary(WSOL)  #> weather  #>       8 names(WSOL) |> head() #> [1] \"WSOL_CL01\" \"WSOL_CL02\" \"WSOL_CL03\" \"WSOL_CL04\" \"WSOL_CL05\" \"WSOL_CL06\""},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"wind","dir":"Articles","previous_headings":"Capacity factors","what":"Wind","title":"IDEEA: Electric power sector model","text":"wind capacity factors defined regions India, based MERRA2 dataset. capacity factors estimated 100m height (wcf100m) merra2ools package, data 5 regions saved ideea_data. Notation: WIN - onshore wind WIF - offshore wind WIND - , onshore offshore wind Wind clusters average wind capacity factors cluster, 100m height","code":"# get clustered capacity factors from `ideea_extra` dataset wind_cf <- get_ideea_cf(\"win\", nreg = nreg, year = 2019, tol = tol_win_cl) #> Reading capacity factors data from: #>    D:/Dropbox/projects/ideea_extra//merra2/cf_win_r32_TOL05_d365_h24_2019.fst  #>    Maximum number of clusters per region: 12 # get map of wind clusters ideea_win_cl_sf <- get_ideea_cl_sf(\"win\", nreg = nreg, tol = tol_win_cl) |>   # update MW_max based on land use assumptions   mutate(     MW_max = if_else(offshore,                       win_offshore_max_MW_km2 * as.numeric(area),                      win_onshore_max_MW_km2 * as.numeric(area)                      )     )  # maximum number of clusters: win_clust_max <- max(wind_cf$cluster)  win_clust_digits <- max(nchar(win_clust_max), 2)  # add column with commodity name for the cluster's land ideea_win_cl_sf <- ideea_win_cl_sf |>   mutate(     land_comm = name_with_cluster(       if_else(offshore, \"LAND_WIF_CL\", \"LAND_WIN_CL\"),       cluster, ndigits = win_clust_digits)   )"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"onshore","dir":"Articles","previous_headings":"Capacity factors > Wind","what":"Onshore","title":"IDEEA: Electric power sector model","text":"","code":"# repository to store onshore wind capacity factors (weather objects) WWIN <- newRepository(name = \"Onshore wind capacity factors\")  # create weather object for every cluster in a loop and store in the repository for (i in unique(wind_cf$cluster)) {   x <- filter(wind_cf, cluster == i, !grepl(\"_off\", wind_cf[[regN_off]]))   # stop()   if (nrow(x) == 0) next   WWIN_i <- newWeather(     name = name_with_cluster(\"WWIN_CL\", i, ndigits = win_clust_digits),     desc = name_with_cluster(       \"Onshore wind 100m height capacity factors, cluster \", i     ),     region = unique(x[[regN]]),     timeframe = \"HOUR\",     weather = data.frame(       region = x[[regN]],       slice = x$slice,       # year = NA # all years       wval = x$wcf_100m     )   )   WWIN <- add(WWIN, WWIN_i)   rm(x, WWIN_i) }  # Check the repository summary(WWIN) #> weather  #>      12 names(WWIN) |> head() #> [1] \"WWIN_CL01\" \"WWIN_CL02\" \"WWIN_CL03\" \"WWIN_CL04\" \"WWIN_CL05\" \"WWIN_CL06\""},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"offshore","dir":"Articles","previous_headings":"Capacity factors > Wind","what":"Offshore","title":"IDEEA: Electric power sector model","text":"","code":"# repository to store offshore wind capacity factors (weather objects) WWIF <- newRepository(name = \"Offshore wind capacity factors\")  # create weather object for every cluster in a loop and store in the repository for (i in unique(wind_cf$cluster)) {   x <- filter(wind_cf, cluster == i, grepl(\"_off\", wind_cf[[regN_off]]))   if (nrow(x) == 0) next   # stop()   WWIF_i <- newWeather(     name = name_with_cluster(\"WWIF_CL\", i, ndigits = win_clust_digits),     desc = name_with_cluster(       \"Offshore wind 100m height capacity factors, cluster \", i,        ndigits = win_clust_digits     ),     region = unique(x[[regN]]),     timeframe = \"HOUR\",     weather = data.frame(       region = x[[regN]],       slice = x$slice,       # year = NA # all years       wval = x$wcf_100m     )   )   WWIF <- add(WWIF, WWIF_i)   rm(x, WWIF_i) }  # Check the repository summary(WWIF) #> weather  #>       7 names(WWIF) |> head() #> [1] \"WWIF_CL01\" \"WWIF_CL02\" \"WWIF_CL03\" \"WWIF_CL04\" \"WWIF_CL05\" \"WWIF_CL06\" # WWIF@data$WWIF_CL01"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"hydro","dir":"Articles","previous_headings":"Capacity factors","what":"Hydro","title":"IDEEA: Electric power sector model","text":"hydro capacity factors based official country-wide hourly data India 2013. simplification used demonstrate model’s capabilities can replaced detailed data available.","code":"# The data is stored in the IDEEA package dataset # ideea_data$hydro_hourly_cf_2013 - raw data hydro_cf <- get_ideea_data(\"hydro_hourly_cf_2013\", raw = TRUE) |>   mutate(slice = dtm2tsl(datetime), .after = \"datetime\")  WHYD <- newWeather(   name = \"WHYD\",   desc = \"Hydro CUF\",   timeframe = \"HOUR\",   weather = data.frame(     # region = NA, # same for all regions     slice = hydro_cf$slice,     # year = NA # same for all years     wval = hydro_cf$cf   ) )"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"generating-technologies","dir":"Articles","previous_headings":"","what":"Generating technologies","title":"IDEEA: Electric power sector model","text":"pre-existing capacity power generation can defined groups technologies, aggregated primary fuel type technological features, efficiency, costs, lifetime, emissions, etc. example use open-source datasets WRI --date corrections represent existing capacity power plants India model regions primary fuels. capacity taken open WRI dataset, technology parameters collected IDEEA group, used define technology objects techs module (ideea_modules$techs). Existing capacity maps (WRI, 2021) Installed capacity primary fuel type 2020","code":"# get WRI data for the existing capacity, aggregated by region and primary fuel cap_0 <- get_ideea_data(   name = \"generators_wri\",   variable = c(\"primary_fuel\", \"capacity_mw\"),   nreg = nreg ) |>   filter(capacity_mw > 0) # drop zeros  # get updated summary data for selected fuel type, 2020, aggregated by region cap_1 <- get_ideea_data(   name = \"generators_2020\",   nreg = nreg,   variable = c(\"Solar\", \"Wind\", \"Biomass\", \"Small Hydro\") ) |>   # reshape the table in long format   pivot_longer(      cols = any_of(c(\"Solar\", \"Wind\", \"Biomass\", \"Small Hydro\")),     names_to = \"primary_fuel\",     values_to = \"capacity_mw\"   )    # combine the datasets (updating WRI data with the newer capacity of renewables) cap <- bind_rows(   filter(cap_0, !grepl(\"Solar|Wind|Biomass\", primary_fuel)),   cap_1 ) |>   # add_reg_off(regN = regN) |>     group_by(across(any_of(     c(regN, regN_off, \"offshore\", \"primary_fuel\")   ))) |>   summarize(capacity_mw = sum(capacity_mw, na.rm = T), .groups = \"drop\") |>   as.data.table()  cap_sf <- ideea_sf |>   right_join(cap) |>   filter(!is.na(primary_fuel), capacity_mw > 10) #> Joining with `by = join_by(offshore, reg32)`  a <- ggplot() +   geom_sf(data = ideea_sf, fill = \"grey\") +   geom_sf(aes(fill = capacity_mw / 1e3), data = cap_sf) +   scale_fill_viridis_c(option = \"H\", name = \"GW\", trans = \"identity\") +   facet_wrap(~primary_fuel) +   theme_bw() +   theme(     # panel.background = element_rect(fill = \"aliceblue\"),     # panel.grid = element_line(color = \"white\", size = 0.8),     axis.ticks = element_blank(),     axis.text = element_blank()   ) # a ggsave(\"tmp/installed_capacity.png\", a,   width = 6, height = 7,   scale = 1.25 ) try(a) cap$primary_fuel |> unique() #> [1] \"Biomass\"     \"Hydro\"       \"Small Hydro\" \"Solar\"       \"Wind\"        #> [6] \"Coal\"        \"Gas\"         \"Nuclear\"     \"Oil\" # summary table cap |>   group_by(primary_fuel, offshore) |>   summarize(capacity_GW = sum(capacity_mw) / 1e3, .groups = \"drop\") |>   arrange(desc(capacity_GW)) |>   knitr::kable(     caption = \"Installed capacity by primary fuel type in 2020\"     )"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"coal-fired","dir":"Articles","previous_headings":"Generating technologies","what":"Coal-fired","title":"IDEEA: Electric power sector model","text":"several generations coal-fired power plants, sub-critical supercritical, ultra-supercritical, different efficiencies, costs, emissions. existing capacity (stock) coal-fired power plants example assumed represented ECOASUP technology average efficiency, linearly retire 2040. advanced technologies (ECOAULT) vintages (2020, 2030, 2040, 2050) available investment. technology carbon capture defined CCS section .","code":"# Existing capacity cap_coa <- cap |>   filter(grepl(\"Coal\", primary_fuel)) |>   filter(!offshore) |>   mutate(year = 2020, .before = 1)  # assume age-based retirement of 2020 capacity by 2030 is 20% cap_coa_2030 <- cap_coa |>   mutate(year = 2030, capacity_mw = 0.8 * capacity_mw)  # assume further retirement of 2020 capacity by 2040 is 90% cap_coa_2040 <- cap_coa |>   mutate(year = 2040, capacity_mw = 0.1 * capacity_mw)  # combine cap_coa <- cap_coa |>   bind_rows(cap_coa_2030) |>   bind_rows(cap_coa_2040) # Note: the existing capacity will be linearly interpolated from 2020 to 2040 # cap = 0 after 2040  # load coal technology (assume Super-critical for all existing capacity) ECOASUP_2020 <- ideea_modules$techs$ECOASUP@data$ECOASUP_2020 class(ECOASUP_2020) #> [1] \"technology\" #> attr(,\"package\") #> [1] \"energyRt\"  # update base-year technology with preexisting capacity ECOASUP_2020 <- ECOASUP_2020 |>   update(capacity = data.frame(     region = cap_coa[[regN]],     year = cap_coa$year,     stock = cap_coa$capacity_mw / 1e3 # in GW   ))  # load most advanced coal techs for new investment ECOA <- ideea_modules$techs$ECOAULT |> # ultra-super-critical   # add(ideea_modules$techs$ECOASUP$ECOASUP_2030) |>   add(ECOASUP_2020) # add tech with existing capacity names(ECOA@data) #> [1] \"ECOAULT_2020\" \"ECOAULT_2030\" \"ECOAULT_2040\" \"ECOAULT_2050\" \"ECOASUP_2020\"  # par_init <- par() # par(mfrow = c(1, 2)) # plot two technologies side-by-side draw(ECOA@data$ECOASUP_2020) # super-critical technology in 2020 # draw(ECOA@data$ECOAULT_2050) # ultra-super-critical technology in 2050 # par(mfrow = par_init$mfrow) # reset to initial settings"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"natural-gas","dir":"Articles","previous_headings":"Generating technologies","what":"Natural gas","title":"IDEEA: Electric power sector model","text":"two key natural gas fired technologies model: combined cycle gas turbine (CCGT) open cycle gas turbine (OCGT). existing capacity gas-fired power plants example assumed represented CCGT (ENGCC) technology, linearly retire 2040. OCGT technology (ENGOC) advanced vintages NGCC available investment. technology carbon capture defined CCS section .","code":"cap_gas <- cap |> # existing capacity   filter(grepl(\"Gas\", primary_fuel)) |>   filter(!offshore) |>   mutate(year = 2020, .before = 1)  # assume retirement of 2020 capacity by 2030 cap_gas_2030 <- cap_gas |>   mutate(year = 2030, capacity_mw = 0.8 * capacity_mw)  # assume retirement of 2020 capacity by 2030 cap_gas_2040 <- cap_gas |>   mutate(year = 2040, capacity_mw = 0.1 * capacity_mw)  # combine cap_gas <- cap_gas |>   bind_rows(cap_gas_2030) |>   bind_rows(cap_gas_2040) # Note: the existing capacity will be linearly interpolated from 2020 to 2040 # cap = 0 after 2040  # load coal technology (assume Super-critical for all existing capacity) ENGCC_2020 <- ideea_modules$techs$ENGCC@data$ENGCC_2020  # update base-year technology with preexisting capacity ENGCC_2020 <- ENGCC_2020 |>   update(capacity = data.frame(     region = cap_gas[[regN]],     year = cap_gas$year,     stock = cap_gas$capacity_mw / 1e3 # in GW   ))  # load most advanced coal techs for new investment EGAS <- ideea_modules$techs$ENGCC |> # Combined cycle gas turbine   add(ENGCC_2020, overwrite = T) |> # technology with pre-existing capacity   add(ideea_modules$techs$ENGOC) # open cycle gas turbine names(EGAS@data) #> [1] \"ENGCC_2020\" \"ENGCC_2030\" \"ENGCC_2040\" \"ENGCC_2050\" \"ENGOC_2020\" #> [6] \"ENGOC_2030\" \"ENGOC_2040\" \"ENGOC_2050\"  draw(EGAS@data$ENGCC_2020) # draw(EGAS@data$ENGCC_2050)"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"solar-1","dir":"Articles","previous_headings":"Generating technologies","what":"Solar","title":"IDEEA: Electric power sector model","text":"solar technologies defined base-year model pre-existing capacity WRI datasets; new technologies available investment represented several vintages solar PV technologies 2050.","code":"# solar capacity in ~2020 cap_sol_2020 <- cap |>   filter(grepl(\"Solar\", primary_fuel)) |>   mutate(year = 2020, .before = 1)  cap_sol <- cap_sol_2020 # base year  # assume retirement of 2020 capacity by 2030 cap_sol_2030 <- cap_sol |>   mutate(year = 2030, capacity_mw = 0.8 * capacity_mw)  # assume further retirement by 2040 cap_sol_2040 <- cap_sol |>   mutate(year = 2040, capacity_mw = 0.1 * capacity_mw)  # combine cap_sol <- cap_sol |>   bind_rows(cap_sol_2030) |>   bind_rows(cap_sol_2040) # Note: the existing capacity will be linearly interpolated from 2020 to 2040 # cap = 0 after 2040  # Create two alternative repositories with solar technologies and constraints # only one of the versions will be used in the model with equal results # but both are created here for demonstration purposes # version \"const\" is using explicit constraints on the capacity ESOL_w_const <- newRepository(   name = \"solar_panels_w_const\",   desc = \"Solar panels with cluster constraints on GW capacity\") # version \"land\" is using land resource as an auxiliary input ESOL_w_land <- newRepository(   name = \"solar_panels_w_land\",   desc = \"Solar panels with land limits per cluster\")  # Solar technologies from IDEEA repository. class(ideea_modules$techs$ESOL) # repository with solar techs #> [1] \"repository\" #> attr(,\"package\") #> [1] \"energyRt\" names(ideea_modules$techs$ESOL) #> [1] \"ESOL_2020\" \"ESOL_2030\" \"ESOL_2040\" \"ESOL_2050\"  for (w in WSOL@data) { # CF by clusters   # stop() # use for debug   cl <- get_cluster(w@name)   stopifnot(!is.na(cl)) # check    # calculate the upper capacity constraint by cluster   cluster_land <- ideea_sol_cl_sf |>     st_drop_geometry() |>     filter(!offshore) |>     filter(cluster %in% as.integer(cl)) |>     select(all_of(c(regN, \"land_comm\", \"cluster\", \"area\", \"MW_max\"))) |>     group_by(across(all_of(c(regN, \"land_comm\", \"cluster\")))) |>     summarise(       area_km2 = round(as.numeric(sum(area, na.rm = T)), 1),       GW_max = round(sum(MW_max, na.rm = T) / 1e3, 3),       .groups = \"drop\"     ) |>     as.data.table()    # check data consistency   stopifnot(all(cluster_land[[regN]] %in% w@region))   stopifnot(length(unique(cluster_land$land_comm)) == 1)    # Declare land commodity   land_comm <- newCommodity(     name = unique(cluster_land$land_comm),     desc = paste0(\"Land resource for solar cluster \", cl),     unit = \"km2\",     timeframe = \"ANNUAL\"   )    # Declare land resource by solar cluster and region   land_res <- newSupply(     name = paste0(\"RES_\", land_comm@name),     commodity = land_comm@name,     desc = paste0(\"Land resource for solar cluster \", cl),     unit = \"km2\",     region = unique(cluster_land[[regN]]),     availability = data.frame(       region = cluster_land[[regN]],       # year = NA_integer_,       ava.up = cluster_land$area_km2     )   )    # temporary lists to store technologies for every cluster and every vintage   techs_cl_const <- list() # version \"const\"   techs_cl_land <- list() # version \"land\"   for (tec in ideea_modules$techs$ESOL@data) { # loop over vintages     # stop() # use for debug      # update prototype technology, \"const\" version     tec_w <- update(       tec,       name = name_with_cluster(paste0(tec@name, \"_CL\"), cl),       weather = list(         weather = w@name,         waf.fx = 1       ),       input = list(comm = \"REN\", unit = \"GWh\", combustion = 0)     )          # \"land\" version of the technology has land-commodity as an auxiliary input     tec_w_land <- update(       tec_w,       aux = list(         acomm = land_comm@name,         unit = \"km2\"       ),       aeff = list(         acomm = land_comm@name,         cap2ainp = 1e3 / sol_onshore_max_MW_km2 # GW/km2       )     )          # add technology to the temporary lists     techs_cl_const[[tec_w@name]] <- tec_w; rm(tec, tec_w)     techs_cl_land[[tec_w_land@name]] <- tec_w_land; rm(tec_w_land)   }      #    CT_ESOL_CL <- newConstraint(     name = paste0(\"CT_ESOL_CL\", cl),     desc = \"Constraint on total solar plants by cluster\",     eq = \"<=\",     for.each = list(       year = NA,       region = w@region     ),     variable = list(       variable = \"vTechCap\",       for.sum = list(         tech = names(techs_cl_const), # list all technologies for the cluster         years = NULL       )     ),     rhs = data.frame(       year = as.numeric(NA),       region = cluster_land[[regN]],       rhs = cluster_land$GW     ),     defVal = Inf,     interpolation = \"back.inter.forth\"   )      # version \"const\"   ESOL_w_const <- add(ESOL_w_const, techs_cl_const, CT_ESOL_CL)   # version \"land\"   ESOL_w_land <- add(ESOL_w_land, techs_cl_land, land_comm, land_res)   rm(land_comm, land_res, techs_cl_const, techs_cl_land, CT_ESOL_CL)    } summary(ESOL_w_const); names(ESOL_w_const) |> head() #> constraint technology  #>          8         32 #> [1] \"ESOL_2020_CL01\" \"ESOL_2030_CL01\" \"ESOL_2040_CL01\" \"ESOL_2050_CL01\" #> [5] \"CT_ESOL_CL01\"   \"ESOL_2020_CL02\" draw(ESOL_w_const$ESOL_2020_CL01) summary(ESOL_w_land); names(ESOL_w_land) |> head() #>  commodity     supply technology  #>          8          8         32 #> [1] \"ESOL_2020_CL01\"    \"ESOL_2030_CL01\"    \"ESOL_2040_CL01\"    #> [4] \"ESOL_2050_CL01\"    \"LAND_SOL_CL01\"     \"RES_LAND_SOL_CL01\" draw(ESOL_w_land$ESOL_2020_CL01)"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"wind-1","dir":"Articles","previous_headings":"Generating technologies","what":"Wind","title":"IDEEA: Electric power sector model","text":"Similarly, wind technologies defined base-year model pre-existing capacity WRI datasets; new technologies available investment represented vintages.","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"onshore-1","dir":"Articles","previous_headings":"Generating technologies > Wind","what":"Onshore","title":"IDEEA: Electric power sector model","text":"","code":"# existing capacity cap_win <- cap |>   filter(grepl(\"Wind\", primary_fuel)) |>   mutate(year = 2020, .before = 1) # correcting the 2020 base year capacity values for wind.  # assume retirement of 2020 capacity by 2030 cap_win_2030 <- cap_win |>   mutate(year = 2030, capacity_mw = 0.8 * capacity_mw)  # assume further retirement by 2040 cap_win_2040 <- cap_win |>   mutate(year = 2040, capacity_mw = 0.1 * capacity_mw)  # combine cap_win <- cap_win |>   bind_rows(cap_win_2030) |>   bind_rows(cap_win_2040) # Note: the existing capacity will be linearly interpolated from 2020 to 2040 # cap = 0 after 2040  # Create two alternative repositories with wind technologies and constraints # only one of the versions will be used in the model with equal results # but both are created here for demonstration purposes # version \"const\" EWIN_w_const <- newRepository(   name = \"wind_turbines_const\",   desc = \"Wind turbines with GW per cluster constraints\") # version \"land\" EWIN_w_land <- newRepository(   name = \"wind_turbines_land\",   desc = \"Wind turbines with land limits per cluster\")  # Wind technologies from IDEEA repository class(ideea_modules$techs$EWIN) # repository with wind techs #> [1] \"repository\" #> attr(,\"package\") #> [1] \"energyRt\" names(ideea_modules$techs$EWIN) #> [1] \"EWIN_2020\" \"EWIN_2030\" \"EWIN_2040\" \"EWIN_2050\"  # Create technology for every cluster and every vintage # (similar to solar above) # wind_land_req <- ideea_win_cl_sf |> #   st_drop_geometry() |> #   select(all_of(c(regN, \"offshore\", \"cluster\", \"area\", \"MW_max\"))) |> #   group_by(across(all_of(c(regN, \"offshore\", \"cluster\")))) |> #   summarise( #     area_km2 = round(as.numeric(sum(area, na.rm = T)), 1), #     MW_max = sum(MW_max, na.rm = T),  #     .groups = \"drop\") |> #   as.data.table()  for (w in WWIN@data) { # CF by clusters   # stop() # use for debug   cl <- get_cluster(w@name)   stopifnot(!is.na(cl)) # check    # calculate the upper capacity constraint by cluster   cluster_land <- ideea_win_cl_sf |>     st_drop_geometry() |>     filter(!offshore) |>     filter(cluster %in% as.integer(cl)) |>     select(all_of(c(regN, \"land_comm\", \"cluster\", \"area\", \"MW_max\"))) |>     group_by(across(all_of(c(regN, \"land_comm\", \"cluster\")))) |>     summarise(       area_km2 = round(as.numeric(sum(area, na.rm = T)), 1),       GW = round(sum(MW_max, na.rm = T) / 1e3, 3),        .groups = \"drop\"       ) |>     as.data.table()        # check data consistency   stopifnot(all(cluster_land[[regN]] %in% w@region))   stopifnot(length(unique(cluster_land$land_comm)) == 1)      # Declare land commodity   land_comm <- newCommodity(     name = unique(cluster_land$land_comm),     desc = paste0(\"Land resource for wind cluster \", cl),     unit = \"km2\",     timeframe = \"ANNUAL\"   )      # Declare land resource by wind cluster and region   land_res <- newSupply(     name = paste0(\"RES_\", land_comm@name),     commodity = land_comm@name,     desc = paste0(\"Land resource for wind cluster \", cl),     unit = \"km2\",     region = unique(cluster_land[[regN]]),     availability = data.frame(       region = cluster_land[[regN]],       # year = NA_integer_,       ava.up = cluster_land$area_km2     )   )      # temporary lists to store technologies for every cluster and every vintage   techs_cl_const <- list() # version \"const\"   techs_cl_land <- list() # version \"land\"   for (tec in ideea_modules$techs$EWIN@data) { # loop over vintages     # stop() # use for debug          # update prototype technology, \"const\" version     tec_w <- update(       tec,       name = name_with_cluster(paste0(tec@name, \"_CL\"), cl),       weather = list(         weather = w@name,         waf.fx = 1       ),       input = list(comm = \"REN\", unit = \"GWh\", combustion = 0)     )          # \"land\" version of the technology has land-commodity as an auxiliary input     tec_w_land <- update(       tec_w,       aux = list(         acomm = land_comm@name,         unit = \"km2\"       ),       aeff = list(         acomm = land_comm@name,         cap2ainp = 1e3 / win_onshore_max_MW_km2 # GW/km2       )     )      # store in lists     techs_cl_const[[tec_w@name]] <- tec_w; rm(tec, tec_w)     techs_cl_land[[tec_w_land@name]] <- tec_w_land; rm(tec_w_land)   }      # assign base-year capacity to clusters    # (arbitrary, geo-location can be matched later)      # stop()   # make a capacity constraint for each cluster   # cluster_GW_max <- ideea_win_cl_sf |>   #   st_drop_geometry() |>   #   # ungroup() |>   #   filter(cluster %in% as.integer(cl)) |>   #   filter(!offshore) |>   #   select(all_of(c(regN, \"cluster\", \"MW_max\"))) |>   #   group_by(across(c(regN, \"cluster\"))) |>   #   summarise(GW = sum(MW_max, na.rm = T) / 1e3, .groups = \"drop\") |>   #   as.data.table()      # check data consistency   # stopifnot(all(cluster_GW_max[[regN]] %in% w@region))      # capacity constraint for version \"const\"   CT_EWIN_CL <- newConstraint(     name = paste0(\"CT_EWIN_CL\", cl),     desc = \"Constraint on total solar plants by cluster\",     eq = \"<=\",     for.each = list(       year = NA,        region = w@region     ),     variable = list(       variable = \"vTechCap\",       for.sum = list(         tech = names(techs_cl_const),         years = NULL       )     ),     rhs = data.frame(       year = as.numeric(NA),       region = cluster_land[[regN]],       rhs = cluster_land$GW     ),     defVal = Inf,     interpolation = \"back.inter.forth\"   )   # EWIN <- add(EWIN, lst_cl, CT_EWIN_CL); rm(lst_cl, CT_EWIN_CL)   # EWIN <- add(EWIN, lst_cl); rm(lst_cl)      # version \"const\"   EWIN_w_const <- add(EWIN_w_const, techs_cl_const, CT_EWIN_CL)   # version \"land\"   EWIN_w_land <- add(EWIN_w_land, land_comm, land_res, techs_cl_land)   rm(land_comm, land_res, techs_cl_const, techs_cl_land, CT_EWIN_CL) } summary(EWIN_w_const); names(EWIN_w_const) |> head() #> constraint technology  #>         12         48 #> [1] \"EWIN_2020_CL01\" \"EWIN_2030_CL01\" \"EWIN_2040_CL01\" \"EWIN_2050_CL01\" #> [5] \"CT_EWIN_CL01\"   \"EWIN_2020_CL02\" summary(EWIN_w_land); names(EWIN_w_land) |> head() #>  commodity     supply technology  #>         12         12         48 #> [1] \"LAND_WIN_CL01\"     \"RES_LAND_WIN_CL01\" \"EWIN_2020_CL01\"    #> [4] \"EWIN_2030_CL01\"    \"EWIN_2040_CL01\"    \"EWIN_2050_CL01\"  # update base-year technology with preexisting capacity # (assigning to first clusters, geo-location can be matched later) # cap_win_exist <- cap_win |> #   group_by(across(all_of(regN))) |> #   summarise(GW_exist = max(capacity_mw) / 1e3, .groups = \"drop\") |> #   rename(region = regN) #  # cap_win_exist_to_cluster <- EWIN$CT_EWIN_CL01@rhs |>  #   right_join(cap_win_exist, by = \"region\") |> #   filter(!is.na(rhs)) #  # for (cl in 1:win_clust_max) { #    #   tname <- name_with_cluster(\"EWIN_2020_CL\", cl,  #                              ndigits = win_clust_digits) #   cap_win_exist_to_cluster[[tname]] <- #     cap_win_exist_to_cluster[[\"GW_exist\"]] #    #   cap_win_exist_to_cluster[[\"diff\"]] <- #     cap_win_exist_to_cluster[[\"rhs\"]] - cap_win_exist_to_cluster[[tname]] #    #   if (any(cap_win_exist_to_cluster[[\"diff\"]] < 0)) { #     ii <- cap_win_exist_to_cluster[[\"diff\"]] >= 0 #     cap_win_exist_to_cluster[[tname]][!ii] <-  #       cap_win_exist_to_cluster[[\"rhs\"]][!ii] #     cap_win_exist_to_cluster <- #       cap_win_exist_to_cluster |> #       mutate( #         GW_exist = if_else(get(\"diff\") >= 0, 0, #                            -get(\"diff\")) #       ) #   } else { #     cap_win_exist_to_cluster$GW_exist <- 0 #   } #   capacity_cl = data.frame( #       region = cap_win_exist_to_cluster$region, #       year = cap_win_exist_to_cluster$year, #       stock = cap_win_exist_to_cluster[[tname]] # in GW #     ) |> #     filter(stock > 0) #    #   EWIN@data[[tname]] <- EWIN@data[[tname]] |> #     update(capacity = capacity_cl) #  #   if (any(cap_win_exist_to_cluster$GW_exist > 0)) break  # }  # names(EWIN) |> head(); length(EWIN) # EWIN@data$EWIN_2020_CL01@weather # EWIN@data$EWIN_2020_CL01 |> draw()"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"offshore-1","dir":"Articles","previous_headings":"Generating technologies > Wind","what":"Offshore","title":"IDEEA: Electric power sector model","text":"","code":"# (assuming) the existing capacity of offshore wind is zero  # Create a repository for offshore wind technologies # \"const\" version EWIF_w_const <- newRepository(   name = \"offshore_wind_turbines_const\",   desc = \"Offshore wind turbines with GW per cluster constraints\") # \"land\" version EWIF_w_land <- newRepository(   name = \"offshore_wind_turbines_land\",   desc = \"Offshore wind turbines with land limits per cluster\")  # Wind technologies from IDEEA repository class(ideea_modules$techs$EWIF) # repository with wind techs #> [1] \"repository\" #> attr(,\"package\") #> [1] \"energyRt\" names(ideea_modules$techs$EWIF) #> [1] \"EWIF_2020\" \"EWIF_2030\" \"EWIF_2040\" \"EWIF_2050\"  # Create technology for every cluster and every vintage # (similar to solar above) for (w in WWIF@data) { # CF by clusters   # stop() # use for debug   cl <- get_cluster(w@name)   # land_comm <- paste0(\"LWIF_CL\", cl)   stopifnot(!is.na(cl))      # calculate the upper capacity constraint by cluster   cluster_land <- ideea_win_cl_sf |>     st_drop_geometry() |>     filter(offshore) |>     filter(cluster %in% as.integer(cl)) |>     select(all_of(c(regN, \"land_comm\", \"cluster\", \"area\", \"MW_max\"))) |>     group_by(across(all_of(c(regN, \"land_comm\", \"cluster\")))) |>     summarise(       area_km2 = round(as.numeric(sum(area, na.rm = T)), 1),       GW = round(sum(MW_max, na.rm = T) / 1e3, 1),        .groups = \"drop\") |>     as.data.table()        # check data consistency   stopifnot(all(cluster_land[[regN]] %in% w@region))   stopifnot(length(unique(cluster_land$land_comm)) == 1)      # Declare land commodity   land_comm <- newCommodity(     name = unique(cluster_land$land_comm),     desc = paste0(\"Land (surface) for offshore wind cluster \", cl),     unit = \"km2\",     timeframe = \"ANNUAL\"   )      # Declare land resource by wind cluster and region   land_res <- newSupply(     name = paste0(\"RES_\", land_comm@name),     commodity = land_comm@name,     desc = paste0(\"Land (surface) resource for offshore wind cluster \", cl),     unit = \"km2\",     region = unique(cluster_land[[regN]]),     availability = data.frame(       region = cluster_land[[regN]],       # year = NA_integer_,       ava.up = cluster_land$area_km2     )   )      # lst_cl <- list() # temporary list   techs_cl_const <- list() # version \"const\"   techs_cl_land <- list() # version \"land\"   for (tec in ideea_modules$techs$EWIF@data) { # vintages     # stop() # use for debug     # update prototype technology     tec_w <- update(       tec,       name = name_with_cluster(paste0(tec@name, \"_CL\"), cl),       weather = list(         weather = w@name,         waf.fx = 1       ),       input = list(comm = \"REN\", unit = \"GWh\", combustion = 0)     )          # \"land\" version of the technology has land-commodity as an auxiliary input     tec_w_land <- update(       tec_w,       aux = list(         acomm = land_comm@name,         unit = \"km2\"       ),       aeff = list(         acomm = land_comm@name,         cap2ainp = 1e3 / win_offshore_max_MW_km2 # GW/km2       )     )          # store in list     # lst_cl[[tec_w@name]] <- tec_w; rm(tec, tec_w)     techs_cl_const[[tec_w@name]] <- tec_w; rm(tec, tec_w)     techs_cl_land[[tec_w_land@name]] <- tec_w_land; rm(tec_w_land)   }   # stop()   # make a capacity constraint for each cluster   # cluster_GW_max <- ideea_win_cl_sf |>   #   st_drop_geometry() |>   #   # ungroup() |>   #   filter(cluster %in% as.integer(cl)) |>   #   filter(offshore) |>   #   select(all_of(c(regN, \"cluster\", \"MW_max\"))) |>   #   group_by(across(c(regN, \"cluster\"))) |>   #   summarise(GW = sum(MW_max, na.rm = T) / 1e3, .groups = \"drop\") |>   #   as.data.table()   #    # check data consistency   # stopifnot(all(cluster_GW_max[[regN]] %in% w@region))      # create capacity constraint   CT_EWIF_CL <- newConstraint(     name = paste0(\"CT_EWIF_CL\", cl),     # desc = \"Constraint on total solar plants by cluster\",     eq = \"<=\",     for.each = list(       year = NA,       region = w@region     ),     variable = list(       variable = \"vTechCap\",       for.sum = list(         tech = names(techs_cl_const),         years = NULL       )     ),     rhs = data.frame(       year = as.numeric(NA),       region = cluster_land[[regN]],       rhs = cluster_land$GW     ),     defVal = Inf,     interpolation = \"back.inter.forth\"   )   # EWIF <- add(EWIF, lst_cl, CT_EWIF_CL); rm(lst_cl, CT_EWIF_CL)   # EWIF <- add(EWIF, lst_cl); rm(lst_cl)   # EWIF <- add(EWIF, land_comm, land_res, lst_cl)   # rm(land_comm, land_res, lst_cl, cluster_land)   EWIF_w_const <- add(EWIF_w_const, techs_cl_const, CT_EWIF_CL)   EWIF_w_land <- add(EWIF_w_land, land_comm, land_res, techs_cl_land)   rm(land_comm, land_res, techs_cl_const, techs_cl_land, CT_EWIF_CL) } summary(EWIF_w_const); names(EWIF_w_const) |> head() #> constraint technology  #>          7         28 #> [1] \"EWIF_2020_CL01\" \"EWIF_2030_CL01\" \"EWIF_2040_CL01\" \"EWIF_2050_CL01\" #> [5] \"CT_EWIF_CL01\"   \"EWIF_2020_CL02\" summary(EWIF_w_land); names(EWIF_w_land) |> head() #>  commodity     supply technology  #>          7          7         28 #> [1] \"LAND_WIF_CL01\"     \"RES_LAND_WIF_CL01\" \"EWIF_2020_CL01\"    #> [4] \"EWIF_2030_CL01\"    \"EWIF_2040_CL01\"    \"EWIF_2050_CL01\""},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"hydro-1","dir":"Articles","previous_headings":"Generating technologies","what":"Hydro","title":"IDEEA: Electric power sector model","text":"decision development hydro-power plants normally goes beyond optimization costs, takes account environmental social impacts, well availability water resources. development hydro-power may take decade, operational lifetime can go beyond century. assume existing capacity hydro-power plants retire (2100), new investments available, projects can added model separate scenario.","code":"cap_hyd <- cap |>   filter(grepl(\"Hydro\", primary_fuel)) |>   mutate(primary_fuel = \"Hydro\") |> # combining Small with other - assumption (!)   # filter(!offshore) |>   group_by(across(any_of(     c(regN, regN_off, \"offshore\", \"primary_fuel\")   ))) |>   summarise(capacity_mw = sum(capacity_mw, na.rm = T), .groups = \"drop\") |>   filter(capacity_mw > 0) |>   mutate(year = 2020, .before = 1)  # assume retirement of 2020 capacity by 2030 cap_hyd_2030 <- cap_hyd |>   mutate(year = 2030, capacity_mw = 1 * capacity_mw)  # assume retirement of 2020 capacity by 2030 cap_hyd_2100 <- cap_hyd |>   mutate(year = 2100, capacity_mw = 1 * capacity_mw)  # combine cap_hyd <- cap_hyd |>   bind_rows(cap_hyd_2030) |>   bind_rows(cap_hyd_2100) # Note: the existing capacity will be linearly interpolated from 2020 to 2040 # cap = 0 after 2040  # load base-year technology EHYD_2020 <- ideea_modules$techs$EHYD@data$EHYD_2020 class(EHYD_2020) #> [1] \"technology\" #> attr(,\"package\") #> [1] \"energyRt\"  # update base-year technology with preexisting capacity EHYD_2020 <- EHYD_2020 |>   update(     capacity = data.frame(       region = cap_hyd[[regN]],       year = cap_hyd$year,       stock = cap_hyd$capacity_mw / 1e3 # in GW     ),     end = list(end = 2010) # not available for investment   )  EHYD <- ideea_modules$techs$EHYD |> #   add(EHYD_2020, overwrite = T) # add tech with existing capacity names(EHYD@data) #> [1] \"EHYD_2020\" \"EHYD_2030\" \"EHYD_2040\" \"EHYD_2050\"  # add weather factor name and parameter for each technology EHYD@data <- lapply(EHYD@data, function(tech) {   update(     tech,     weather = data.frame(weather = \"WHYD\", waf.fx = 1),     input = list(comm = \"REN\", combustion = 0)   ) }) names(EHYD@data) #> [1] \"EHYD_2020\" \"EHYD_2030\" \"EHYD_2040\" \"EHYD_2050\" EHYD@data$EHYD_2020@weather #>   weather comm wafc.lo wafc.up wafc.fx waf.lo waf.up waf.fx wafs.lo wafs.up #> 1    WHYD <NA>      NA      NA      NA     NA     NA      1      NA      NA #>   wafs.fx #> 1      NA  draw(EHYD@data$EHYD_2020)"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"nuclear","dir":"Articles","previous_headings":"Generating technologies","what":"Nuclear","title":"IDEEA: Electric power sector model","text":"Nuclear power plants also quite controversial, decision development based long-term energy policy, availability uranium resources, safety environmental concerns, public acceptance. assume existing capacity nuclear power plants retire (2050) linear fading 2080. new investments limited separate constraint (see Policies section), can dropped relaxed particulate scenarios decided.","code":"cap_nuc <- cap |>   filter(grepl(\"Nuclear\", primary_fuel)) |>   filter(!offshore) |>   mutate(year = 2020, .before = 1)  # assume no retirement up to 2050 cap_nuc_2050 <- cap_nuc |>   mutate(year = 2050, capacity_mw = 1 * capacity_mw)  # linear retirement from 2050 capacity by 2080 cap_nuc_LAST <- cap_nuc |>   mutate(year = 2080, capacity_mw = 1e-20 * capacity_mw)  # combine cap_nuc <- cap_nuc |>   bind_rows(cap_nuc_2050) |>   bind_rows(cap_nuc_LAST)  # load base-year technology ENUC_2020 <- ideea_modules$techs$ENUC@data$ENUC_2020 class(ENUC_2020) #> [1] \"technology\" #> attr(,\"package\") #> [1] \"energyRt\"  # update base-year technology with preexisting capacity ENUC_2020 <- ENUC_2020 |>   update(     capacity = data.frame(       region = cap_nuc[[regN]],       year = cap_nuc$year,       stock = cap_nuc$capacity_mw / 1e3 # in GW     ),     end = list(end = 2010) # not available for investment   )  ENUC <- ideea_modules$techs$ENUC |> # all nuclear techs   add(ENUC_2020, overwrite = T) # replace with the existing capacity names(ENUC@data) #> [1] \"ENUC_2020\" \"ENUC_2030\" \"ENUC_2040\" \"ENUC_2050\"  draw(ENUC@data$ENUC_2020)"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"ccs","dir":"Articles","previous_headings":"Generating technologies","what":"CCS","title":"IDEEA: Electric power sector model","text":"Coal- gas-fired power plants carbon capture storage (CCS) technologies defined “ccus” article stored ideea_modules$CCUS repository. two types CCS technologies: fixed flexible capture rates. fixed capture rate assumed used time technology produces electricity, flexible capture rate can adjusted depending policy carbon market conditions. add flexible CCS technologies.","code":"# add coal and gas CCS techs from `ideea_modules$CCUS` ccus_module <- ideea_modules$CCUS  repo_ccstechs <- newRepository(   name = \"CCS Technologies\",   desc = \"Repository for CCS technologies\",   ccus_module$CCSCO2, # commodity to represent captured CO2   ccus_module$GHG, # composite commodity--all GHGs      ## option 1: Fixed CCS technology (see CCUS description)   # ccus_module$ECOA_CCS_FX, # Coal plant with CCS   # ccus_module$EGAS_CCS_FX, # Natural gas plant with CCS      ## option 2: Variable CCS technology   ccus_module$COA0, # coal commodity with captured CO2   ccus_module$ALIAS_COA, # alias name COA == COA0 for supply   ccus_module$ECOA_CCS_FL, # Coal power plant with variable CCS tech   ccus_module$GAS0, # gas commodity with captured CO2   ccus_module$ALIAS_GAS, # alias name GAS0 == CAS for supply   ccus_module$EGAS_CCS_FL # gas power plant with variable CCS tech )  rm(ccus_module)"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"bio-energy","dir":"Articles","previous_headings":"Generating technologies","what":"Bio energy","title":"IDEEA: Electric power sector model","text":"biomass-fired power plants represented EBIO technology existing capacity WRI dataset. new investments available biomass technologies different vintages 2050. don’t consider CCS biomass technologies example, can added needed.","code":"cap_bio <- cap |>   filter(grepl(\"Biomass\", primary_fuel)) |>   filter(!offshore) |>   mutate(year = 2020, .before = 1)  # assume retirement of 2020 capacity by 2030 cap_bio_2030 <- cap_bio |>   mutate(year = 2030, capacity_mw = 1 * capacity_mw)  # assume retirement of 2020 capacity by 2030 cap_bio_2060 <- cap_bio |>   mutate(year = 2060, capacity_mw = 1 * capacity_mw)  # combine cap_bio <- cap_bio |>   bind_rows(cap_bio_2030) |>   bind_rows(cap_bio_2060)  # load base-year technology EBIO_2020 <- ideea_modules$techs$EBIO@data$EBIO_2020 class(EBIO_2020) #> [1] \"technology\" #> attr(,\"package\") #> [1] \"energyRt\"  # update base-year technology with preexisting capacity EBIO_2020 <- EBIO_2020 |>   update(capacity = data.frame(     region = cap_bio[[regN]],     year = cap_bio$year,     stock = cap_bio$capacity_mw / 1e3 # in GW   ))  EBIO <- ideea_modules$techs$EBIO |> #   add(EBIO_2020, overwrite = T) # add tech with existing capacity names(EBIO@data) #> [1] \"EBIO_2020\" \"EBIO_2030\" \"EBIO_2040\" \"EBIO_2050\"  draw(EBIO@data$EBIO_2020)"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"energy-storage","dir":"Articles","previous_headings":"","what":"Energy storage","title":"IDEEA: Electric power sector model","text":"","code":"# ideea_modules$techs STG_BTR <- ideea_modules$techs$STG_BTR STG_BTR$STG_BTR_2020@fullYear # storage cycle over year or withing YDAY #> [1] TRUE  # create daily storage (optional) STG_BTR_daily <- STG_BTR STG_BTR_daily@data <- lapply(STG_BTR_daily@data, function(ob) {   if (.hasSlot(ob, \"fullYear\")) ob@fullYear <- FALSE   ob }) STG_BTR_daily$STG_BTR_2020@fullYear #> [1] FALSE"},{"path":[]},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"hvac","dir":"Articles","previous_headings":"Transmission","what":"HVAC","title":"IDEEA: Electric power sector model","text":"HVAC cost: INR 1.56 Cr/km/GW Losses: 7%-10% per 1000km HVDC Cost: INR 3-5 Cr/km Losses: 1-3% per 1000km","code":"network <- ideea_data$transmission[[regN]] |>   filter(case == transmission_matrix, !is.na(MW)) |>   # rename(dst = region1) |>   filter(MW >= 0)  repo_transmission_ac <- newRepository(\"transmission\") if (nrow(network) > 0) {   for (i in 1:nrow(network)) {     trd <- newTrade(       name = network$trd_name_ac[i],       desc = paste0(\"Bi-directional HVAC transmission line between \",                     network$region.x[i], \" and \",                     network$region.y[i],                      ifelse(is.null(network$lines_type[i]), \"\",                             paste0(\" (\", network$lines_type[i], \")\"))                     ),       commodity = \"ELC\",       routes = data.frame(         src = c(network$region.x[i], network$region.y[i]),         dst = c(network$region.y[i], network$region.x[i])       ),       trade = data.frame(         src = c(network$region.x[i], network$region.y[i]),         dst = c(network$region.y[i], network$region.x[i]),         teff = c(network$AC_eff[i], network$AC_eff[i])       ),       capacityVariable = T,       invcost = data.frame(         # convert(1000, \"USD/MW/mi\", \"cr.INR/GW/km\") ~= 5 cr.INR/GW/km         # see: https://www.nrel.gov/docs/fy22osti/81662.pdf         region = c(network$region.x[i], network$region.y[i]),         invcost = rep(network$AC_invcost[i] / 2, 2) # olife == 2       ),       olife = list(olife = 60), # doubled annualized invcost for consistency       start = list(start = base_year - 10),       capacity = data.frame(         year = c(2020, 2030, 2050, 2070),         stock = c(           network$MW[i] / 1000, network$MW[i] / 1000,           network$MW[i] / 1000, network$MW[i] / 1000         ),         # ncap.up = 5, # upper limit on new transmission by year         cap.up = max(2 * network$MW[i] / 1000 + 10, 10) # upper limit on transmission capacity       ),       cap2act = 24 * 365     )     repo_transmission_ac <- add(repo_transmission_ac, trd)     rm(trd)   } } names(repo_transmission_ac) #>  [1] \"HVAC_APY_OR\"  \"HVAC_APY_TG\"  \"HVAC_APY_TNY\" \"HVAC_AR_AS\"   \"HVAC_AR_NL\"   #>  [6] \"HVAC_AS_ML\"   \"HVAC_BR_CT\"   \"HVAC_BR_JH\"   \"HVAC_BR_SK\"   \"HVAC_BR_UP\"   #> [11] \"HVAC_CT_MP\"   \"HVAC_CT_OR\"   \"HVAC_CT_TG\"   \"HVAC_DL_HR\"   \"HVAC_DL_RJ\"   #> [16] \"HVAC_DL_UP\"   \"HVAC_DL_UT\"   \"HVAC_GA_GJN\"  \"HVAC_GA_KA\"   \"HVAC_GA_KLY\"  #> [21] \"HVAC_GA_MH\"   \"HVAC_GJN_MH\"  \"HVAC_GJN_MP\"  \"HVAC_GJN_RJ\"  \"HVAC_HP_JK\"   #> [26] \"HVAC_HP_PBH\"  \"HVAC_HP_UT\"   \"HVAC_HR_PBH\"  \"HVAC_JH_OR\"   \"HVAC_JH_WB\"   #> [31] \"HVAC_KA_KLY\"  \"HVAC_KA_TG\"   \"HVAC_KA_TNY\"  \"HVAC_KLY_TNY\" \"HVAC_MH_MP\"   #> [36] \"HVAC_MH_TG\"   \"HVAC_ML_SK\"   \"HVAC_ML_TR\"   \"HVAC_MN_MZ\"   \"HVAC_MN_NL\"   #> [41] \"HVAC_MP_RJ\"   \"HVAC_MP_UP\"   \"HVAC_MZ_TR\"   \"HVAC_OR_WB\"   \"HVAC_PBH_RJ\"  #> [46] \"HVAC_SK_WB\"   \"HVAC_TR_WB\"   \"HVAC_UP_UT\" repo_transmission_ac[[1]] #> An object of class \"trade\" #> Slot \"name\": #> [1] \"HVAC_APY_OR\" #>  #> Slot \"desc\": #> [1] \"Bi-directional HVAC transmission line between APY and OR\" #>  #> Slot \"commodity\": #> [1] \"ELC\" #>  #> Slot \"routes\": #>   src dst #> 1 APY  OR #> 2  OR APY #>  #> Slot \"trade\": #>   src dst year slice ava.up ava.fx ava.lo      teff #> 1 APY  OR   NA  <NA>     NA     NA     NA 0.9244707 #> 2  OR APY   NA  <NA>     NA     NA     NA 0.9244707 #>  #> Slot \"aux\": #> [1] acomm unit  #> <0 rows> (or 0-length row.names) #>  #> Slot \"aeff\": #> [1] acomm     src       dst       year      slice     csrc2aout csrc2ainp #> [8] cdst2aout cdst2ainp #> <0 rows> (or 0-length row.names) #>  #> Slot \"invcost\": #>   region year invcost wacc retcost #> 1    APY   NA     817   NA      NA #> 2     OR   NA     817   NA      NA #>  #> Slot \"fixom\": #> [1] region year   fixom  #> <0 rows> (or 0-length row.names) #>  #> Slot \"varom\": #> [1] src    dst    year   varom  markup #> <0 rows> (or 0-length row.names) #>  #> Slot \"olife\": #>   year olife #> 1   NA    60 #>  #> Slot \"start\": #>   start #> 1  2009 #>  #> Slot \"end\": #>   end #> 1 Inf #>  #> Slot \"capacity\": #>   year stock cap.lo cap.up cap.fx ncap.lo ncap.up ncap.fx ret.lo ret.up ret.fx #> 1 2020     0     NA     10     NA      NA      NA      NA     NA     NA     NA #> 2 2030     0     NA     10     NA      NA      NA      NA     NA     NA     NA #> 3 2050     0     NA     10     NA      NA      NA      NA     NA     NA     NA #> 4 2070     0     NA     10     NA      NA      NA      NA     NA     NA     NA #>  #> Slot \"capacityVariable\": #> [1] TRUE #>  #> Slot \"cap2act\": #> [1] 8760 #>  #> Slot \"optimizeRetirement\": #> [1] FALSE #>  #> Slot \"misc\": #> list()"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"hvdc","dir":"Articles","previous_headings":"Transmission","what":"HVDC","title":"IDEEA: Electric power sector model","text":"","code":"EDC <- newCommodity(   name = \"EDC\",   desc = \"Ultra high voltage DC electricity\",   unit = \"GWh\" )  # Converters (inverter and rectifier stations) EDC2ELC <- newTechnology(   name = \"EDC2ELC\",   desc = \"Inverter station\",   input = list(comm = \"EDC\", unit = \"GWh\"),   output = list(comm = \"ELC\", unit = \"GWh\"),   invcost = list(     invcost = 500   ),    ceff = list(     comm = \"ELC\",     cact2cout = .99     ),   olife = list(olife = 30),   cap2act = 24 * 365 ) draw(EDC2ELC) ELC2EDC <- newTechnology(   name = \"ELC2EDC\",   desc = \"Rectifier station\",   output = list(comm = \"EDC\", unit = \"GWh\"),   input = list(comm = \"ELC\", unit = \"GWh\"),   invcost = list(     invcost = 500   ),    ceff = list(     comm = \"EDC\",     cact2cout = .99),   olife = list(olife = 30),   cap2act = 24 * 365 ) draw(ELC2EDC) repo_transmission_dc <-    newRepository(name = \"transmission_dc\", EDC, EDC2ELC, ELC2EDC)  if (nrow(network) > 0) {   for (i in 1:nrow(network)) {     trd <- newTrade(       name = network$trd_name_dc[i],       desc = paste0(\"Bi-directional HVDC transmission line between \",                     network$region.x[i], \" and \",                     network$region.y[i],                      ifelse(is.null(network$lines_type[i]), \"\",                             paste0(\" (\", network$lines_type[i], \")\"))                     ),       commodity = \"EDC\",       routes = data.frame(         src = c(network$region.x[i], network$region.y[i]),         dst = c(network$region.y[i], network$region.x[i])       ),       trade = data.frame(         src = c(network$region.x[i], network$region.y[i]),         dst = c(network$region.y[i], network$region.x[i]),         teff = c(network$DC_eff[i], network$DC_eff[i])       ),       capacityVariable = T,       invcost = data.frame(         # convert(1000, \"USD/MW/mi\", \"cr.INR/GW/km\") ~= 5 cr.INR/GW/km         # see: https://www.nrel.gov/docs/fy22osti/81662.pdf         region = c(network$region.x[i], network$region.y[i]),         invcost = rep(network$DC_invcost[i] / 2, 2) # olife == 2       ),       olife = list(olife = 60), # doubled annualized invcost for consistency       start = list(start = base_year - 10),       capacity = data.frame(         year = c(2020, 2030, 2050, 2070),         stock = c(           network$MW[i] / 1000, network$MW[i] / 1000,           network$MW[i] / 1000, network$MW[i] / 1000         ),         cap.up = 100 # upper limit on transmission capacity       ),       cap2act = 24 * 365     )     repo_transmission_dc <- add(repo_transmission_dc, trd)     rm(trd)   } } names(repo_transmission_dc) #>  [1] \"EDC\"          \"EDC2ELC\"      \"ELC2EDC\"      \"HVDC_APY_OR\"  \"HVDC_APY_TG\"  #>  [6] \"HVDC_APY_TNY\" \"HVDC_AR_AS\"   \"HVDC_AR_NL\"   \"HVDC_AS_ML\"   \"HVDC_BR_CT\"   #> [11] \"HVDC_BR_JH\"   \"HVDC_BR_SK\"   \"HVDC_BR_UP\"   \"HVDC_CT_MP\"   \"HVDC_CT_OR\"   #> [16] \"HVDC_CT_TG\"   \"HVDC_DL_HR\"   \"HVDC_DL_RJ\"   \"HVDC_DL_UP\"   \"HVDC_DL_UT\"   #> [21] \"HVDC_GA_GJN\"  \"HVDC_GA_KA\"   \"HVDC_GA_KLY\"  \"HVDC_GA_MH\"   \"HVDC_GJN_MH\"  #> [26] \"HVDC_GJN_MP\"  \"HVDC_GJN_RJ\"  \"HVDC_HP_JK\"   \"HVDC_HP_PBH\"  \"HVDC_HP_UT\"   #> [31] \"HVDC_HR_PBH\"  \"HVDC_JH_OR\"   \"HVDC_JH_WB\"   \"HVDC_KA_KLY\"  \"HVDC_KA_TG\"   #> [36] \"HVDC_KA_TNY\"  \"HVDC_KLY_TNY\" \"HVDC_MH_MP\"   \"HVDC_MH_TG\"   \"HVDC_ML_SK\"   #> [41] \"HVDC_ML_TR\"   \"HVDC_MN_MZ\"   \"HVDC_MN_NL\"   \"HVDC_MP_RJ\"   \"HVDC_MP_UP\"   #> [46] \"HVDC_MZ_TR\"   \"HVDC_OR_WB\"   \"HVDC_PBH_RJ\"  \"HVDC_SK_WB\"   \"HVDC_TR_WB\"   #> [51] \"HVDC_UP_UT\" # (optional) filter out some lines in mountainous regions repo_transmission_dc@data[[\"HVDC_HP_JK\"]] <- NULL repo_transmission_dc@data[[\"HVDC_SK_WB\"]] <- NULL repo_transmission_dc@data[[\"HVDC_BR_SK\"]] <- NULL repo_transmission_dc@data[[\"HVDC_ML_SK\"]] <- NULL"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"unserved-load","dir":"Articles","previous_headings":"","what":"Unserved load","title":"IDEEA: Electric power sector model","text":"","code":"UNSERVED <- newImport(   name = \"UNSERVED\",   desc = \"Unserved load, ~ 10 cr.INR/GWh, equal 100 INR/kWh\",   commodity = \"ELC\",   unit = \"GWh\",   imp = list(price = 100) )"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"policies","dir":"Articles","previous_headings":"","what":"Policies","title":"IDEEA: Electric power sector model","text":"carbon emissions, climate, air quality, SOx, NOx, PM, etc. * national * state, local regulations electric power sector optional, additional constraint Solar Capacity Deployment across regions. default, constraint capacity set every cluster regions based available (estimated) land area solar radiation. However, constraint can adjusted region separately defined 5-region model case.","code":"CO2_CAP <- newConstraint(   name = \"CO2_CAP\",   eq = \"<=\",   rhs = list(     year = c(2025, 2060, 2100),     rhs = c(900000, 1e-10, 1e-10) # CO2 cap assumptions   ),   for.each = list(year = 2025:2100), # Cap total emission   variable = list(     variable = \"vBalance\",     for.sum = list(       comm = \"CO2\",       slice = NULL,       region = NULL     )   ),   defVal = Inf,   interpolation = \"inter.forth\" ) CO2_CAP@rhs #>   year   rhs #> 1 2025 9e+05 #> 2 2060 1e-10 #> 3 2100 1e-10 NO_NEW_HYDRO <- newConstraint(   name = \"NO_NEW_HYDRO\",   # desc = \"Constraint on new Hydro plants construction\",   eq = \"<=\",   for.each = list(year = NULL),   variable = list(     variable = \"vTechNewCap\",     for.sum = list(       tech = c(\"EHYD_2030\", \"EHYD_2040\", \"EHYD_2050\", \"EHYD_2020\"),       region = NULL     )   ),   rhs = data.frame(     year = c(2020, 2060),     rhs = c(1e-20)   ),   defVal = 1e-20,   interpolation = \"inter.forth\" )  NO_NEW_NUCLEAR <- newConstraint(   name = \"NO_NEW_NUCLEAR\",   # desc = \"Constraint on new Hydro plants construction\",   eq = \"<=\",   for.each = list(year = 2020:2060),   variable = list(     variable = \"vTechNewCap\",     for.sum = list(       tech = c(\"ENUC_2030\", \"ENUC_2040\", \"ENUC_2050\", \"ENUC_2020\"),       region = NULL     )   ),   rhs = data.frame(     year = c(2020:2060),     rhs = 1e-20     # rhs = c(1e-7) #eps   ),   defVal = 1e-20,   interpolation = \"inter.forth\" )  # dput(names(ESOL)) NO_NEW_SOLAR <- newConstraint(   name = \"NO_NEW_SOLAR\",   # desc = \"Constraint on new Hydro plants construction\",   eq = \"<=\",   for.each = list(year = 2020:2060),   variable = list(     variable = \"vTechNewCap\",     for.sum = list(       tech = names(ESOL_w_const)[grepl(\"^ESOL\", names(ESOL_w_const))],       region = NULL     )   ),   rhs = data.frame(     year = c(2020:2060),     rhs = 1e-20     # rhs = c(1e-7) #eps   ),   defVal = 1e-20,   interpolation = \"inter.forth\" )  NO_NEW_WIND <- newConstraint(   name = \"NO_NEW_WIND\",   # desc = \"Constraint on new Hydro plants construction\",   eq = \"<=\",   for.each = list(year = 2020:2060),   variable = list(     variable = \"vTechNewCap\",     for.sum = list(       tech = names(EWIN_w_const)[grepl(\"^EWIN\", names(EWIN_w_const))],       region = NULL     )   ),   rhs = data.frame(     year = c(2020:2060),     rhs = 1e-20   ),   defVal = 1e-20,   interpolation = \"inter.forth\" )  # dput(names(EGAS)) CT_EGAS <- newConstraint(   name = \"CT_EGAS\",   # desc = \"Constraint on new Hydro plants construction\",   eq = \"<=\",   for.each = list(year = c(2020, 2055)),   variable = list(     variable = \"vTechNewCap\",     for.sum = list(       tech = names(EGAS),       region = NULL     )   ),   rhs = list(     year = c(2020, 2055),     rhs = c(5, 5)   ),   defVal = 1e-20,   interpolation = \"inter.forth\" ) # limit on hydro construction # No Base year investment NO_BY_INV <- newConstraint(   name = \"NO_BY_INV\",   eq = \"<=\",   for.each = list(year = c(2020, 2021, 2060)),   variable = list(     variable = \"vTechNewCap\",     for.sum = list(       tech = NA,       region = NA     )   ),   rhs = data.frame(     year = c(2020, 2021, 2060),     rhs = c(1e-20, 1e10, 1e10) #   ),   defVal = 1e10, # large number (Inf may not work as expected in some solvers)   interpolation = \"inter.forth\" ) if (nreg == 5) {   # optional constraint for total solar capacity on top of cluster constraints   CT_ESOL_TOT <- newConstraint(     name = \"CT_ESOL\",     desc = \"Constraint on solar plants capacity by region\",     eq = \"<=\",     for.each = list(       year = NA,       region = c(\"EAST\", \"NORTH\", \"NORTHEAST\", \"SOUTH\", \"WEST\")     ),     variable = list(       variable = \"vTechCap\",       for.sum = list(         # list all solar technologies         tech = names(ESOL_w_const)[grepl(\"^ESOL\", names(ESOL_w_const))],         year = NULL       )     ),     rhs = data.frame(       year = as.numeric(NA),       region = c(\"NORTH\", \"SOUTH\", \"EAST\", \"WEST\", \"NORTHEAST\"),       # adjust numbers according to your assumptions       rhs = c(336.250, 107.330, 66.360, 180.9, 57.36) # upper limit     ),     defVal = Inf,     interpolation = \"back.inter.forth\"   ) } else { # for other models   CT_ESOL_TOT <- NULL # adjust the above constraint for your model if needed }"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"model","dir":"Articles","previous_headings":"","what":"Model","title":"IDEEA: Electric power sector model","text":"","code":"repo <- newRepository(   name = glue(\"repo_electricity_{regN}\"),   # commodities   repo_comm,   # supply & import   repo_supply,   # Generating technologies   ECOA,   EGAS, CT_EGAS, # gas-fired generators with limit on construction   ENUC,   NO_NEW_NUCLEAR, # limit on nuclear construction   EHYD, WHYD,   NO_NEW_HYDRO, # limit on hydro construction   WSOL, # solar capacity factors   ESOL_w_const, # solar generators with capacity constraints version   # ESOL_w_land, # solar generators with land constraints version   WWIN, # onshore wind capacity factors   EWIN_w_const, # onshore wind generators with capacity constraints version   # EWIN_w_land, # onshore wind generators with land constraints version   WWIF, # offshore wind capacity factors   EWIF_w_const, # offshore wind generators with capacity constraints version   # EWIF_w_land, # offshore wind generators with land constraints version   EBIO,    # battery   STG_BTR, # storage with annual cycle   # STG_BTR_daily, # alternative storage with daily cycle   # transmission   repo_transmission_ac,   repo_transmission_dc,   repo_geoccs,   repo_ccstechs,   # unserved load   UNSERVED, # unserved load penalty   # demand   DEMELC_BY, # BY demand   DEMELC_2X, # additional demand   # CT_ESOL, # solar capacity constraints   NO_BY_INV # )  # print(repo) # names(repo) summary(repo) #>  commodity constraint     demand     import    storage     supply technology  #>         17         31          2          5          4          6        139  #>      trade    weather  #>         92         28  # model horizon # horizon_2020_2060_by_10 <- newHorizon( #   period = 2020:2060, #   intervals = c(1, 5, rep(10, 15)), #   mid_is_end = T # ) # horizon_2020_2060_by_10  # model-class object mod <- newModel(   name = glue(\"IDEEA_ELC_{regN}\"),   desc = \"IDEEA electricity example model\",   region = unique(ideea_sf[[regN]]),   discount = 0.05,   calendar = ideea_modules$calendars$calendar_d365_h24,   horizon = ideea_modules$calendars$horizon_2020_2060_by_10,   data = repo ) # mod@config@horizon@intervals # mod@config@calendar@timetable"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"solving-the-model","dir":"Articles","previous_headings":"","what":"Solving the model","title":"IDEEA: Electric power sector model","text":"Note: full model requires powerful solver (CPLEX GUROBI) GAMS Julia Python + CPLEX/GUROBI also work, currently require time generate problem solver. recommended solve model portion year (subset time-slices), can solved free solvers HiGHS Cbc.","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"reference-scenario---subset","dir":"Articles","previous_headings":"Solving the model","what":"Reference scenario - subset","title":"IDEEA: Electric power sector model","text":"Quick way glimpse results","code":"# set_progress_bar(\"progress\") # Reference case scen_REF_sub <- interpolate_model(   mod,   name = \"REF_sub\", # indicating 'subset'   calendar = ideea_modules$calendars$calendar_d365_h24_subset_1day_per_month,   horizon = ideea_modules$horizons$horizon_2050 )  # directory to store the scenario scen_REF_sub@path   scen_REF_sub <- write_sc(   scen_REF_sub,   solver = solver_options$gams_gdx_cplex_barrier   # solver = solver_options$gams_gdx_cplex_parallel   # solver = solver_options$julia_highs_barrier   # solver = solver_options$julia_highs_simplex   # solver = solver_options$julia_highs_parallel ) scen_REF_sub@status scen_REF_sub@misc$tmp.dir  # solve_scenario(scen_REF_sub, wait = F, force = F) scen_REF_sub <- solve(scen_REF_sub, wait = F, tmp.del = F) scen_REF_sub <- read(scen_REF_sub)  # store scenario on disk (unload from RAM) scen_REF_sub <- save_scenario(scen_REF_sub) summary(scen_REF_sub)"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"policy-scenarios","dir":"Articles","previous_headings":"Solving the model","what":"Policy scenarios","title":"IDEEA: Electric power sector model","text":"","code":"# CO2 cap scen_CAP_sub <- interpolate(   mod,   name = \"CAP_sub\", # indicating 'subset'   # path = file.path(\"scenarios\", glue(\"CAP_sub_r{nreg}_debug\")),   # here we can add policy objects   # STG_BTR_daily, # Battery, modeled with daily cycle for sampled calendar   CO2_CAP,   calendar = ideea_modules$calendars$calendar_d365_h24_subset_1day_per_month,   # horizon = ideea_modules$calendars$horizon_2020_2060_by_10   ideea_modules$horizons$horizon_2050   # partial_calendar # add partial calendar to the interpolate function )  # scen_CAP_sub@path <- file.path( #   ideea_scenarios(), #   ideea_scenario_dir_name( #     name = \"CAP_sub\",  #     model_name = mod@name,  #     calendar_name = \"d365_h24\",  #     horizon_name = \"2050\" # )) scen_CAP_sub@path  scen_CAP_sub <- write_sc(   scen_CAP_sub,   # solver = solver_options$gams_gdx_cplex_barrier   # solver = solver_options$gams_gdx_cplex_parallel   # solver = solver_options$pyomo_glpk   # solver = solver_options$pyomo_cbc   solver = solver_options$julia_highs_barrier   # solver = solver_options$julia_highs_simplex   # solver = solver_options$julia_highs_parallel ) scen_CAP_sub scen_CAP_sub@misc$tmp.dir  solve_scenario(scen_CAP_sub, wait = F, force = F) # scen_CAP_sub <- solve(scen_CAP_sub, wait = T, tmp.del = F) scen_CAP_sub <- read(scen_CAP_sub)  # store scenario on disk (unload from RAM) scen_CAP_sub <- save_scenario(scen_CAP_sub) summary(scen_CAP_sub) scen_REF <- interpolate_model(   mod,    name = \"REF\",    ideea_modules$horizons$horizon_2050 ) scen_REF  scen_REF <- write_sc(   scen_REF,   solver = solver_options$gams_gdx_cplex_barrier   # solver = solver_options$gams_gdx_cplex_parallel   # solver = solver_options$julia_highs_barrier   # solver = solver_options$julia_highs_simplex   # solver = solver_options$julia_highs_parallel ) scen_REF@status scen_REF@misc$tmp.dir  # solve_scenario(scen_REF, wait = F, force = F) scen_REF <- solve(scen_REF, wait = F, tmp.del = F) scen_REF <- read(scen_REF)  # store scenario on disk (unload from RAM) scen_REF <- save_scenario(scen_REF) summary(scen_REF) set_progress_bar()  horizon_2040_2060_by_20 <-   newHorizon(     name = \"hz2040-2060by20L1\",     period = 2040:2060,     intervals = c(1, rep(20, 3)),     # intervals = rep(20, 4),      mid_is_end = T   ) horizon_2040_2060_by_20@intervals$start <-    horizon_2040_2060_by_20@intervals$end  # CO2 cap scen_CAP <- interpolate(   mod,   name = \"CAP\", # indicating 'subset'   # path = file.path(\"scenarios\", glue(\"CAP_r{nreg}_debug\")),   # here we can add policy objects   # STG_BTR_daily, # Battery, modeled with daily cycle for sampled calendar   CO2_CAP,   horizon_2040_2060_by_20   # ideea_modules$horizons$horizon_2050   # horizon_2050   # partial_calendar # add partial calendar to the interpolate function )  # scen_CAP@path <- file.path( #   ideea_scenarios(), #   ideea_scenario_dir_name( #     name = \"CAP\",  #     model_name = mod@name,  #     calendar_name = \"d365_h24\",  #     horizon_name = \"2060\" #   )) scen_CAP@path  scen_CAP <- write_sc(   scen_CAP,   solver = solver_options$gams_gdx_cplex_barrier   # solver = solver_options$gams_gdx_cplex_parallel   # solver = solver_options$pyomo_glpk   # solver = solver_options$julia_highs_barrier   # solver = solver_options$julia_highs_simplex   # solver = solver_options$julia_highs_parallel ) scen_CAP  # save(scen_CAP, file = file.path(scen_CAP@path, \"scen_CAP_interpolated.RData\"))  solve_scenario(scen_CAP, wait = F, force = F) scen_CAP <- read(scen_CAP) # scen_CAP <- solve(scen_CAP, wait = T, tmp.del = F)  # store scenario on disk (unload from RAM) scen_CAP <- save_scenario(scen_CAP) summary(scen_CAP) # installr::os.sleep()"},{"path":[]},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"compare-scenarios","dir":"Articles","previous_headings":"Results","what":"Compare scenarios","title":"IDEEA: Electric power sector model","text":"","code":"# create a list of sns <- list(   # scen_REF,   scen_CAP   # scen_REF_sub   # scen_CAP_sub   # .scen$CAP_sub,   # .scen$REF_sub )  # compare objective (in cr.₹) getData(sns, \"vObjective\", merge = T) # use `?getData` for help getData(sns, \"vBalance\", comm = \"CO2\", merge = T, digits = 1,          drop.zeros = T) |>    # group_by(name, year) |>    # summarize(GWh = sum(value)) |>    pivot_wider(names_from = scenario, values_from = value)"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"total-installed-capacity","dir":"Articles","previous_headings":"Results > Compare scenarios","what":"Total installed capacity","title":"IDEEA: Electric power sector model","text":"","code":"# compare generating tech capacity (names start with \"E\") vTechCap <- getData(sns,   name = \"vTechCap\", tech_ = \"^E\", process = T,   merge = T, digits = 3, drop.zeros = T )  vTechCap |>   pivot_wider(names_from = scenario) |>   as.data.table() # getData(scen_CAP_sub, \"vImportRow\", imp = \"UNSERVED\", #         digits = 1, drop.zeros = T, merge = T) |>  #   group_by(name, comm) |>  #   summarize(GWh = sum(value))  getData(sns, \"pDemand\", digits = 1, drop.zeros = T, merge = T) |>    group_by(scenario, name, comm) |>    summarize(GWh = sum(value))"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"total-capacity-map","dir":"Articles","previous_headings":"Results > Compare scenarios","what":"Total capacity map","title":"IDEEA: Electric power sector model","text":"","code":"vTechCap_agg <- vTechCap |>   drop_process_cluster() |>   drop_process_vintage() |>    group_by(scenario, process, region, year) |>   summarise(GW = sum(value, na.rm = T), .groups = \"drop\") |>   as.data.table() |>   full_join(ideea_sf, by = c(region = regN_off),     relationship = \"many-to-many\") |>   filter(!is.na(process)) |>   # filter(year %in% c(2020, 2035, 2060)) |>   st_as_sf()  ggplot() +   geom_sf(data = ideea_sf) +   geom_sf(aes(fill = GW), data = vTechCap_agg, na.rm = T) +   scale_fill_viridis_c(option = \"H\", transform = \"sqrt\") +   # scale_fill_viridis_c(option = \"C\", transform = \"log10\") +   # facet_grid(process~scenario) +   facet_wrap(scenario~process) +   theme_ideea_map()  vTechCap_agg |> st_drop_geometry() |>    group_by(scenario, process, year) |>   summarise(GW = sum(GW)) |>   pivot_wider(names_from = scenario, values_from = GW)"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"solar-capacity-by-cluster","dir":"Articles","previous_headings":"Results > Compare scenarios","what":"Solar capacity by cluster","title":"IDEEA: Electric power sector model","text":"","code":"add_cluster_column <- function(x, col_name = \"process\") {   x |> mutate(     cluster = as.integer(str_extract(get(col_name), \"[0-9]+$\")),     .after = col_name   ) }  vTechCap_ESOL_sf <-   vTechCap |>   filter(grepl(\"ESOL\", process)) |> # select solar techs   add_cluster_column() |> # add cluster number   # add shapes for every cluster   left_join(ideea_sol_cl_sf,     by = c(region = regN_off, cluster = \"cluster\"),     relationship = \"many-to-many\"   ) |>   rename(GW = value) |>   filter(!is.na(GW), GW > 0) |>   # filter(year %in% c(2020, 2035, 2060)) |>   st_as_sf() # force to treat 'geometry' column as shape-data  ggplot() +   geom_sf(data = ideea_sf) +   geom_sf(aes(fill = GW), data = vTechCap_ESOL_sf, color = NA, na.rm = T) +   # scale_fill_viridis_c(option = \"H\") +   scale_fill_viridis_c(option = \"C\", transform = \"log10\") +   facet_grid(year ~ scenario) +   theme_ideea_map()"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"wind-capacity-by-cluster","dir":"Articles","previous_headings":"Results > Compare scenarios","what":"Wind capacity by cluster","title":"IDEEA: Electric power sector model","text":"","code":"vTechCap_EWIN_sf <-   vTechCap |>   filter(grepl(\"EWIN\", process)) |> # select solar techs   add_cluster_column() |> # add cluster number   # add shapes for every cluster   left_join(ideea_win_cl_sf,     by = c(region = regN_off, cluster = \"cluster\"),     relationship = \"many-to-many\"   ) |>   rename(GW = value) |>   filter(!is.na(GW), GW > 0) |>   # filter(year %in% c(2020, 2035, 2060)) |>   st_as_sf() # force to treat 'geometry' column as shape-data  ggplot() +   geom_sf(data = ideea_sf) +   geom_sf(aes(fill = GW), data = vTechCap_EWIN_sf, color = NA, na.rm = T) +   scale_fill_viridis_c(option = \"D\") +   # scale_fill_viridis_c(option = \"D\", transform = \"log10\") +   facet_grid(year ~ scenario) +   theme_ideea_map()"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"network","dir":"Articles","previous_headings":"Results > Compare scenarios","what":"Network","title":"IDEEA: Electric power sector model","text":"","code":"vTradeCap <- getData(sns, \"vTradeCap\", merge = T, digits = 1)  vTradeCap_HVAC <- vTradeCap |>   filter(grepl(\"HVAC\", trade)) |>   as.data.table()   vTradeCap_HVDC <- vTradeCap |>   filter(grepl(\"HVDC\", trade)) |>   as.data.table()  b_ac <- a |>   select(-starts_with(\"lon\"), -starts_with(\"lat\")) |>   left_join(network, by = c(\"region\" = \"region.x\",                              dst = \"region.y\",                             \"case\" = \"case\")) |>   # left_join(filter(vTradeCap, year %in% max(vTradeCap$year)),   left_join(vTradeCap,              by = c(\"trd_name_ac\" = \"trade\")) |>   mutate(     type = \"HVAC\"   )  b_dc <- a |>   select(-starts_with(\"lon\"), -starts_with(\"lat\")) |>   left_join(network, by = c(\"region\" = \"region.x\",                              dst = \"region.y\",                             \"case\" = \"case\")) |>   # left_join(filter(vTradeCap, year %in% max(vTradeCap$year)),   left_join(vTradeCap,              by = c(\"trd_name_dc\" = \"trade\")) |>   mutate(     type = \"HVDC\"   )  b <- rbind(b_ac, b_dc) |>   as.data.table()  ggplot() +   geom_sf(data = ideea_sf, fill = \"wheat\") +   geom_segment(     aes(       x = lon.x, y = lat.x, xend = lon.y, yend = lat.y,       linewidth = value     ),     color = \"dodgerblue\", lineend = \"round\", alpha = .75,     data = filter(b, value > 1)   ) +   # geom_segment(aes(x = lon.x, y = lat.x, xend = lon.y, yend = lat.y),   #   color = alpha(\"white\", .5), lineend = \"round\",   #   data = filter(a, case == \"new\")   # ) +   geom_point(aes(lon, lat), data = points_coord, color = \"red\") +   labs(x = \"\", y = \"\") +   facet_grid(year~type) +   guides(fill = guide_legend(title = \"GW\")) +   theme_ideea_map() ggsave(\"tmp/network.png\", width = 6, height = 4, scale = 1.25)"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"dc-converter-stations","dir":"Articles","previous_headings":"Results > Compare scenarios","what":"DC converter stations","title":"IDEEA: Electric power sector model","text":"","code":"vTechCap_DC <- getData(sns, \"vTechCap\", tech_ = \"ELC2EDC|EDC2ELC\",                         merge = T, digits = 1, process = T) |>   as.data.table()  vTechCap_DC_sf <- getData(sns, \"vTechCap\", tech_ = \"ELC2EDC|EDC2ELC\",                            merge = T, digits = 1, process = T) |>   # drop_process_cluster() |>   drop_process_vintage() |>    group_by(scenario, process, region, year) |>   summarise(GW = sum(value, na.rm = T), .groups = \"drop\") |>   filter(GW > 0) |>   full_join(ideea_sf, by = c(region = regN_off),     relationship = \"many-to-many\") |>   filter(!is.na(process)) |>   # filter(year %in% c(2020, 2035, 2060)) |>   st_as_sf() vTechCap_DC_sf$GW |> summary()  ggplot() +   geom_sf(data = ideea_sf) +   geom_sf(aes(fill = GW), na.rm = T,            data = filter(vTechCap_DC_sf, GW > 1)) +   scale_fill_viridis_c(option = \"D\") +   # scale_fill_viridis_c(option = \"C\", transform = \"log10\") +   facet_grid(scenario~process) +   # facet_wrap(scenario~process) +   labs(title = \"HVAC/HVDC converter stations\",        subtitle = \"EDC2ELC - electricity import, ELC2EDC - export\") +   theme_ideea_map() ggsave(\"tmp/DC_converter_stations.png\", width = 6, height = 4,         scale = 1.25)"},{"path":"https://ideea-model.github.io/IDEEA/articles/electricity.html","id":"unserved","dir":"Articles","previous_headings":"Results > Compare scenarios","what":"Unserved","title":"IDEEA: Electric power sector model","text":"","code":"getData(sns, \"vImportRow\", comm = \"ELC\", drop.zeros = T, merge = F)    # group_by(name, comm) |>    # summarize(GWh = sum(value))"},{"path":"https://ideea-model.github.io/IDEEA/articles/energy.html","id":"settings","dir":"Articles","previous_headings":"","what":"Settings","title":"Primary energy sources","text":"","code":"nreg <- 5  # nreg <- 32 # alternative number of regions library(IDEEA) # devtools::load_all(\".\") library(tidyverse) library(data.table) library(cowplot) library(ggthemes) library(glue)  # load IDEEA map gis_r32_sf <- get_ideea_map(nreg = 32, offshore = TRUE, islands = TRUE) gis_sf <- get_ideea_map(nreg = nreg, offshore = TRUE, islands = TRUE)  # create repository for energy-sector objects repo_energy <- newRepository(   name = \"repo_energy\",   desc = \"Primary energy supply\" )  # region names where offshore regions (if any) associated with closest land-region: regN <- glue(\"reg{nreg}\")  # offshore regions have distinct names: regN_off <- glue(\"reg{nreg}_off\")"},{"path":"https://ideea-model.github.io/IDEEA/articles/energy.html","id":"coal-and-lignite","dir":"Articles","previous_headings":"","what":"Coal and Lignite","title":"Primary energy sources","text":"India ranks fifth globally proven coal reserves 361.41 billion tonnes identified, 2.36% increase reserves due recent discoveries. half reserves classified proven. Coal predominantly located Jharkhand, Odisha, Chhattisgarh. Additionally, India holds 46.02 billion metric tons lignite coal, primarily Tamil Nadu, significant portion yet classified proven. Lignite production decreased 13.04% fiscal year 2020-21, reflecting 1.60% CAGR decline past decade. Lignite’s main use electricity generation, consumes 84.46% output. improve auction process lignite mines, India developing National Lignite Index, akin National Coal Index, facilitated Indian Statistical Institute, Kolkata.","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/energy.html","id":"definition-of-commodity-and-supply","dir":"Articles","previous_headings":"Coal and Lignite","what":"Definition of commodity and supply","title":"Primary energy sources","text":"Total coal reserves production 2021 state","code":"# definition of commodity COA <- newCommodity(   name = \"COA\",    desc = \"Coal, all types\",   unit = \"GWh\",    #slice = \"ANNUAL\",   timeframe = \"ANNUAL\",   emis = data.frame(     comm = \"CO2\",     unit = \"kt/GWh\",     emis = 0.33 # emissions from combustion of 1 unit   ),   misc = list(     emis_source = \"https://www.eia.gov/environment/emissions/co2_vol_mass.php\",     emis_conv = 'convert(\"kg/MMBtu\", \"kt/GWh\", 96)'   ) )  # loading and processing coal data coa_reserve <- get_ideea_data(   name = \"coal\",    nreg = nreg,    variable = \"total_reserve_Mt\",   agg_fun = sum   )  coa_sup <-    get_ideea_data(\"coal\", nreg = nreg, \"production\", agg_fun = sum) |>   full_join(     get_ideea_data(\"coal\", nreg = nreg, \"cost_USD_t_2020\", agg_fun = mean)   ) |>   full_join(coa_reserve) |>   replace_na(list(production_2021 = 0)) |>   mutate(     production_2060 = ceiling(total_reserve_Mt / 30) # assume 30 years of supply   )  coa_ava <- coa_sup |>   select(-total_reserve_Mt) |>   rename(production_2020 = production_2021) |>   pivot_longer(cols = c(production_2020, production_2060),                 names_prefix = \"production_\", names_transform = as.integer,                names_to = \"year\", values_to = \"Mt\") |>   mutate(GWh = round(convert(\"Mtce\", \"GWh\", .7 * Mt), digits = -2)) |> # ~70% energy content   as.data.table()  # define domestic supply of coal SUP_COA <- newSupply(   name = \"SUP_COA\",   desc = \"Domestic coal supply, all grades\",   commodity = \"COA\",   region = unique(coa_ava[[regN]]),   unit = \"GWh\",   reserve = data.frame( # maximum      region = coa_sup[[regN]],     res.up = round(convert(\"Mtce\", \"GWh\", .7 * coa_sup$total_reserve_Mt ))   ),   availability = data.frame(     year = coa_ava$year,     region = coa_ava[[regN]],     ava.up = coa_ava$GWh,     cost = signif(convert(\"USD/tce\", \"cr.INR/GWh\",                            coa_ava$cost_USD_t_2020 * .7), 3)   ) )  # import from other countries, makes supply of coal available in any region IMP_COA <- newImport(   name = \"IMP_COA\",   desc = \"Import of coal from abroad\",   commodity = \"COA\",   unit = \"GWh\",   imp = data.frame(     # region = NA, # all regions     price = 2 * mean(SUP_COA@availability$cost, na.rm = T) # assuming double costs   ) )  # saving the model objects in repository repo_energy <- add(repo_energy, COA, SUP_COA, IMP_COA) summary(repo_energy) #> commodity    import    supply  #>         1         1         1"},{"path":"https://ideea-model.github.io/IDEEA/articles/energy.html","id":"oil","dir":"Articles","previous_headings":"","what":"Oil","title":"Primary energy sources","text":"Oil gas pivotal within energy mix, constituting one-third energy requirements due economic growth population increase driving demand annually. 2020-21, crude oil production stood 30.49 million metric tons (MMT). India’s imports included 196.46 MMT crude oil valued Rs 459,779 crores, 43.25 MMT petroleum products Rs 109,430 crores, 24.8 MMT liquefied natural gas (LNG) costing Rs 54,850 crores. imports accounted 21.4% country’s total imports year. Conversely, export petroleum products reached 56.77 MMT, value Rs 157,168 crores. Total oil reserves region","code":"# loading and processing oil data # get_ideea_data(name = \"oil\", raw = T) # check oil_sup <-    get_ideea_data(     name = \"oil\", nreg = nreg, variable = \"reserve\", agg_fun = sum     ) |>   full_join(get_ideea_data(     name = \"oil\", nreg = nreg, variable = \"cost\", agg_fun = mean     ), by = regN) |>   filter(oil_reserve_GWh_2021 > 0) # Declaration of commodity OIL <- newCommodity(   name = \"OIL\",    desc = \"Oil and products\",   unit = \"GWh\",    #slice = \"ANNUAL\",   timeframe = \"ANNUAL\",   emis = data.frame(     comm = \"CO2\",     unit = \"kt/GWh\",     emis = 0.25 # emissions from combustion of 1 unit   ),   misc = list(     emis_source = \"https://www.eia.gov/environment/emissions/co2_vol_mass.php\",     emis_conv = 'convert(\"kg/MMBtu\", \"kt/GWh\", 74)'   ) )  # Declaration of domestic supply SUP_OIL <- newSupply(   name = \"SUP_OIL\",   desc = \"Domestic oil supply\",   commodity = \"OIL\",   unit = \"GWh\",   region = unique(oil_sup[[regN]]),   reserve = data.frame(     region = oil_sup[[regN]],     res.up = oil_sup$oil_reserve_GWh_2021   ),   availability = data.frame(     region = oil_sup[[regN]],     ava.up = oil_sup$oil_reserve_GWh_2021 / 30, # assumption     cost = convert(\"USD/kWh\", \"cr.INR/GWh\", oil_sup$oil_cost_USD_kWh)   ) )  # Declaration of import from other countries,  # makes supply of oil available in any region IMP_OIL <- newImport(   name = \"IMP_OIL\",   desc = \"Import of oil from abroad\",   commodity = \"OIL\",   unit = \"GWh\",   imp = data.frame(     # region = NA, # all regions     price = 2 * mean(SUP_OIL@availability$cost, na.rm = T) # assuming double costs   ) )  # saving the model objects in repository repo_energy <- add(repo_energy, OIL, SUP_OIL, IMP_OIL) repo_energy |> summary() #> commodity    import    supply  #>         2         2         2 repo_energy |> names() #> [1] \"COA\"     \"SUP_COA\" \"IMP_COA\" \"OIL\"     \"SUP_OIL\" \"IMP_OIL\""},{"path":"https://ideea-model.github.io/IDEEA/articles/energy.html","id":"gas","dir":"Articles","previous_headings":"","what":"Gas","title":"Primary energy sources","text":"Government India determined promote usage natural gas, fuel feedstock across country, increase share primary energy mix around 6.7% 15% 2030 [1]. estimated CBM resources order 2600 BCM 91 Trillion TCF spread 11 states country. Natural Gas Production 2020-21 stood 28.67 BCM. Currently, 2575 sq. kms CBM resources available India. 280.357 BCM CBM, 112.63 BCM CBM recoverable reserves [2]. Total gas reserves region","code":"# loading and processing oil data get_ideea_data(name = \"gas\", raw = T) # check raw data #>      reg36 reg36_off   reg1 offshore                 name36  name1 #>     <char>    <char> <char>   <lgcl>                 <char> <char> #>  1:     AP        AP    IND    FALSE         Andhra Pradesh  India #>  2:     AP    AP_off    IND     TRUE         Andhra Pradesh  India #>  3:     AR        AR    IND    FALSE      Arunachal Pradesh  India #>  4:     AS        AS    IND    FALSE                  Assam  India #>  5:     BR        BR    IND    FALSE                  Bihar  India #>  6:     CH        CH    IND    FALSE             Chandigarh  India #>  7:     CT        CT    IND    FALSE           Chhattisgarh  India #>  8:     DD        DD    IND    FALSE          Daman and Diu  India #>  9:     DD    DD_off    IND     TRUE          Daman and Diu  India #> 10:     DL        DL    IND    FALSE                  Delhi  India #> 11:     DN        DN    IND    FALSE Dadra and Nagar Haveli  India #> 12:     GA        GA    IND    FALSE                    Goa  India #> 13:     GA    GA_off    IND     TRUE                    Goa  India #> 14:     GJ        GJ    IND    FALSE                Gujarat  India #> 15:     GJ    GJ_off    IND     TRUE                Gujarat  India #> 16:     HP        HP    IND    FALSE       Himachal Pradesh  India #> 17:     HR        HR    IND    FALSE                Haryana  India #> 18:     JH        JH    IND    FALSE              Jharkhand  India #> 19:     JK        JK    IND    FALSE      Jammu and Kashmir  India #> 20:     KA        KA    IND    FALSE              Karnataka  India #> 21:     KA    KA_off    IND     TRUE              Karnataka  India #> 22:     KL        KL    IND    FALSE                 Kerala  India #> 23:     KL    KL_off    IND     TRUE                 Kerala  India #> 24:     MH        MH    IND    FALSE            Maharashtra  India #> 25:     MH    MH_off    IND     TRUE            Maharashtra  India #> 26:     ML        ML    IND    FALSE              Meghalaya  India #> 27:     MN        MN    IND    FALSE                Manipur  India #> 28:     MP        MP    IND    FALSE         Madhya Pradesh  India #> 29:     MZ        MZ    IND    FALSE                Mizoram  India #> 30:     NL        NL    IND    FALSE               Nagaland  India #> 31:     OR        OR    IND    FALSE                 Odisha  India #> 32:     OR    OR_off    IND     TRUE                 Odisha  India #> 33:     PB        PB    IND    FALSE                 Punjab  India #> 34:     PY        PY    IND    FALSE             Puducherry  India #> 35:     PY    PY_off    IND     TRUE             Puducherry  India #> 36:     RJ        RJ    IND    FALSE              Rajasthan  India #> 37:     SK        SK    IND    FALSE                 Sikkim  India #> 38:     TG        TG    IND    FALSE              Telangana  India #> 39:     TN        TN    IND    FALSE             Tamil Nadu  India #> 40:     TN    TN_off    IND     TRUE             Tamil Nadu  India #> 41:     TR        TR    IND    FALSE                Tripura  India #> 42:     UP        UP    IND    FALSE          Uttar Pradesh  India #> 43:     UT        UT    IND    FALSE            Uttarakhand  India #> 44:     WB        WB    IND    FALSE            West Bengal  India #> 45:     WB    WB_off    IND     TRUE            West Bengal  India #>      reg36 reg36_off   reg1 offshore                 name36  name1 #>     gas_reserve_Bcm_2021 gas_reserve_GWh_2021 gas_cost_USD_kWh #>                    <num>                <num>            <num> #>  1:                65.50               695028             0.03 #>  2:                   NA                   NA               NA #>  3:                 3.14                33319             0.03 #>  4:               166.63              1768129             0.03 #>  5:                   NA                   NA               NA #>  6:                   NA                   NA               NA #>  7:                   NA                   NA               NA #>  8:                   NA                   NA               NA #>  9:                   NA                   NA               NA #> 10:                   NA                   NA               NA #> 11:                   NA                   NA               NA #> 12:                   NA                   NA               NA #> 13:                   NA                   NA               NA #> 14:                56.79               602605             0.03 #> 15:                   NA                   NA               NA #> 16:                   NA                   NA               NA #> 17:                   NA                   NA               NA #> 18:                   NA                   NA               NA #> 19:                   NA                   NA               NA #> 20:                   NA                   NA               NA #> 21:                   NA                   NA               NA #> 22:                   NA                   NA               NA #> 23:                   NA                   NA               NA #> 24:                   NA                   NA               NA #> 25:                   NA                   NA               NA #> 26:                   NA                   NA               NA #> 27:                   NA                   NA               NA #> 28:                   NA                   NA               NA #> 29:                   NA                   NA               NA #> 30:                 0.09                  955             0.03 #> 31:                   NA                   NA               NA #> 32:                   NA                   NA               NA #> 33:                   NA                   NA               NA #> 34:                   NA                   NA               NA #> 35:                   NA                   NA               NA #> 36:                59.06               626692             0.03 #> 37:                   NA                   NA               NA #> 38:                   NA                   NA               NA #> 39:                37.89               402055             0.03 #> 40:                   NA                   NA               NA #> 41:                29.18               309632             0.03 #> 42:                   NA                   NA               NA #> 43:                   NA                   NA               NA #> 44:                   NA                   NA               NA #> 45:                   NA                   NA               NA #>     gas_reserve_Bcm_2021 gas_reserve_GWh_2021 gas_cost_USD_kWh gas_reserve <- get_ideea_data(name = \"gas\", nreg = nreg,                                variable = \"reserve\", agg_fun = sum) gas_ava_assumption <- get_ideea_data(name = \"gas_ava_assumption\",                                       nreg = nreg,                                       variable = \"ava.up\", agg_fun = sum) |>   left_join(     get_ideea_data(name = \"gas_ava_assumption\",                     nreg = nreg,                     variable = \"cost\", agg_fun = mean)   )   # Declaration of commodity GAS <- newCommodity(   name = \"GAS\",    desc = \"Natural gas, all types\",   unit = \"GWh\",    #slice = \"ANNUAL\", deprecated   timeframe = \"ANNUAL\",   emis = data.frame(     comm = \"CO2\",     unit = \"kt/GWh\",     emis = 0.18 # emissions from combustion of 1 unit    ),   misc = list(     emis_source = \"https://www.eia.gov/environment/emissions/co2_vol_mass.php\",     emis_conv = 'convert(\"kg/MMBtu\", \"kt/GWh\", 53)'   ) )  # Declaration of domestic supply SUP_GAS <- newSupply(   name = \"SUP_GAS\",   desc = \"Domestic natural supply\",   commodity = \"GAS\",   unit = \"GWh\",   region = unique(gas_ava_assumption[[regN]]),   reserve = data.frame(     region = gas_reserve[[regN]],     res.up = gas_reserve$gas_reserve_GWh_2021    ) |> unique(),   availability = data.frame(     region = gas_ava_assumption[[regN]],     year = gas_ava_assumption$year,     ava.up = gas_ava_assumption$ava.up,     cost = gas_ava_assumption$cost   ) )  # Declaration of import from other countries, # (makes supply of oil available in any region) IMP_GAS <- newImport(   name = \"IMP_GAS\",   desc = \"Import of natural gas from abroad\",   commodity = \"GAS\",   unit = \"GWh\",   imp = data.frame(     # region = NA, # all regions     #price = 2 * mean(SUP_GAS@availability$cost, na.rm = T) # assuming double costs     price = 100 * mean(SUP_GAS@availability$cost, na.rm = T) # assuming high costs   ) )  # saving the model objects in repository repo_energy <- add(repo_energy, GAS, SUP_GAS, IMP_GAS, overwrite = T) repo_energy@data |> names() #> [1] \"COA\"     \"SUP_COA\" \"IMP_COA\" \"OIL\"     \"SUP_OIL\" \"IMP_OIL\" \"GAS\"     #> [8] \"SUP_GAS\" \"IMP_GAS\""},{"path":"https://ideea-model.github.io/IDEEA/articles/energy.html","id":"ccs","dir":"Articles","previous_headings":"","what":"CCS","title":"Primary energy sources","text":"Source: Carbon Capture, Utilization Storage (CCUS) Policy Framework Deployment Mechanism India Utilization Storage (CCUS)https://www.niti.gov./sites/default/files/2022-11/CCUS-Report.pdf","code":"# Data on the potential of CO2 storage in geological formations # NOTE: the original data is by 5 regions, disaggregation is used for higher nreg ccs_reserve <- get_ideea_data(name = \"ccs_r5\", nreg = nreg)  # Declaration of domestic supply # A commodity to represent the storage of CO2 CO2SINK <- newCommodity(   name = \"CO2SINK\",    desc = \"Stored CO2 in geological formations\",   unit = \"kt\",    timeframe = \"ANNUAL\" )  # Declaration of domestic carbon sink resources RES_CO2SINK <- newSupply(   name = \"RES_CO2SINK\",   desc = \"Permanent geological carbon storage (saline aquifers and basalt).\",   commodity = \"CO2SINK\",   unit = \"kt\",   region = unique(ccs_reserve[[regN]]),   reserve = data.frame(     region = ccs_reserve[[regN]],     res.up = ccs_reserve$CCS_potential_GtCO2 * 1e6   ) |> unique(),   availability = list(     # represent injection costs per unit of stored CO2     cost = convert(12.1, \"USD/t\", \"cr.₹/kt\") # ~0.1 cr.₹/kt, assumption   ) )  # Saving the model objects in repository repo_energy <- add(repo_energy, CO2SINK, RES_CO2SINK, overwrite = F) repo_energy@data |> names() #>  [1] \"COA\"         \"SUP_COA\"     \"IMP_COA\"     \"OIL\"         \"SUP_OIL\"     #>  [6] \"IMP_OIL\"     \"GAS\"         \"SUP_GAS\"     \"IMP_GAS\"     \"CO2SINK\"     #> [11] \"RES_CO2SINK\""},{"path":"https://ideea-model.github.io/IDEEA/articles/energy.html","id":"bio","dir":"Articles","previous_headings":"","what":"Bio","title":"Primary energy sources","text":"Centre Energy Studies Report assesses biomass power bagasse cogeneration potential India, covering gross cropped area 2015 2018, 198.11 million hectares across different seasons. period saw production approximately 774.38 million tonnes selected crops, leading estimated biomass potential 754.50 million tonnes applying crop-specific Crop Residue Ratios (CRR). significant portion (two-thirds, 525.98 million tonnes) biomass used domestic purposes, leaving surplus 228.52 million tonnes. surplus biomass generate estimated 28.5 GWe power, major contributions states like Punjab, Uttar Pradesh, Gujarat, Maharashtra, Madhya Pradesh, Andhra Pradesh. Future projections biomass power potential, based trends 2015 2018, suggest increase 30,883.21 MWe 2020-21, 32,937.83 MWe 2025-26, 35,994.52 MWe 2030-31. growth biomass power potential result expanded agricultural areas, changes crop patterns, improved utilization residual biomass. Total bio reserves region","code":"# loading and processing data # get_ideea_data(name = \"biomass\", raw = T) # check raw data bio_sup <- get_ideea_data(name = \"biomass\",                            nreg = nreg,                            variable = \"max_MWe\") |>   filter(max_MWe > 0) |>   mutate(        )  # bio_ava <-  #   get_ideea_data(\"biomass_ava_assumption\", nreg = nreg,  #                  variable = \"ava.up\", agg_fun = sum) |> #   full_join( #     get_ideea_data(\"biomass_ava_assumption\", nreg = nreg,  #                    variable = \"cost\", agg_fun = mean) #     )  # Declaration of commodity BIO <- newCommodity(   name = \"BIO\",    desc = \"Biomass, all types\",   unit = \"GWh\",    timeframe = \"ANNUAL\",   emis = data.frame(     comm = \"PM25\",     unit = \"kt/GWh\",     emis = 0.1   ) )  # Declaration of domestic supply RES_BIO <- newSupply(   name = \"RES_BIO\",   desc = \"Local biomass resource\",   commodity = \"BIO\",   unit = \"GWh\",   availability = data.frame(     region = bio_sup[[regN]],     # year = bio_sup$year,     ava.up = bio_sup$max_MWe / 1e3 * 8760 * 0.5, # assume 50% CF     cost = 0.247934 # assumption convert(0.247934, \"cr.INR/GWh\", \"USD/kWh\")   ),   # availability = data.frame(   #   region = bio_ava[[regN]],   #   year = bio_ava$year,   #   ava.up = bio_ava$ava.up,   #   cost = bio_ava$cost   # ),   region = unique(bio_sup[[regN]]) )  # saving the model objects in repository repo_energy <- add(repo_energy, BIO, RES_BIO) repo_energy@data |> names() #>  [1] \"COA\"         \"SUP_COA\"     \"IMP_COA\"     \"OIL\"         \"SUP_OIL\"     #>  [6] \"IMP_OIL\"     \"GAS\"         \"SUP_GAS\"     \"IMP_GAS\"     \"CO2SINK\"     #> [11] \"RES_CO2SINK\" \"BIO\"         \"RES_BIO\""},{"path":"https://ideea-model.github.io/IDEEA/articles/energy.html","id":"wind","dir":"Articles","previous_headings":"","what":"Wind","title":"Primary energy sources","text":"per National Institute Wind Energy (NIWE), installable wind potential India 50 m, 80m, 100 m 120m ground level 49 GW, 103 GW 302 GW respectively [2, 3]. commercially exploitable wind potential 200 GW. Currently, total installed capacity wind India around 41 GW .e., 20% total commercially exploitable potential [4]. Tamil Nādu, Gujarat, Karnataka, Rajasthan & Maharashtra top 5 wind energy potential states [5]. India also blessed 7600 km coast line estimated -shore wind potential around 194 GW. Coastal area Gujarat coastline Rameshwaram Kanyakumari offer offshore wind potential almost around 71GW [6, 7]. wind speed available -mentioned coastal areas around 7 m/s – 9m/s [8]. capital cost investment required 1 MW wind power plant installation around 5 – 5.5 Crores levelized cost generation around INR 2-3. [9].","code":"ideea_cl_sf <- get_ideea_cl_sf(resource = \"win\", tol = 0.05) |> # plot(ideea_cl_sf[\"MW_max\"]) # ideea_cl_sf |>    group_by(across(any_of(     c(regN, regN_off, \"mainland\", \"offshore\", \"cluster\"))     )) |>   summarise(     MW_max = sum(MW_max),     geometry = sf::st_union(geometry)   )  ggplot() +   geom_sf(data = ideea_sf) +   geom_sf(aes(fill = MW_max/1e3), data = ideea_cl_sf) +   scale_fill_viridis_c(option = \"H\", name = \"GW\") +   theme_map()"},{"path":"https://ideea-model.github.io/IDEEA/articles/energy.html","id":"solar","dir":"Articles","previous_headings":"","what":"Solar","title":"Primary energy sources","text":"Solar power Generation India 67 GW[6] accounts 16% total power generation India. Financial Year 2022-23, total 102 Billion Units[7] Solar power generated. total potential solar power India estimated 748GW. However estimates solar power based used land assumptions current state technology. National Solar Mission launched 2010 promote ecological sustainable growth addressing India’s energy security challenges. also constitute major contribution India global effort meet challenges climate change. Mission’s objective establish India global leader solar energy creating policy conditions solar technology diffusion across country quickly possible.[11] policy target 100 GW installed capacity Solar power India 2022, achieved installed capacity 62GW 2022. estimated 2026, 100 GW solar power installed India can become net exporter Solar power[12].","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/energy.html","id":"hydro","dir":"Articles","previous_headings":"","what":"Hydro","title":"Primary energy sources","text":"India, hydroelectric plants categorised large hydro (>25MW) small hydro (≤25MW). Government authorities conduct periodic studies estimating potential large hydro plants. Data large hydro potential, capacity operation capacity construction till March 2023 collated [https://pib.gov./PressReleasePage.aspx?PRID=1909276] installed capacity small hydro plants till June 2023 obtained [https://mnre.gov./img/documents/uploads/file_s-1689077131891.pdf]. Construction hydro projects typically involve long construction periods due sites prone geological surprises. makes difficult determine unified levelized price varies project project. However, large hydro projects installed last years, average price observed work INR 5.42 per kWh [https://energy.economictimes.indiatimes.com/news/power/reviving-indias-sleeping-energy-giant-hydro-pumped-hydro-power/97294420]","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/energy.html","id":"nuclear","dir":"Articles","previous_headings":"","what":"Nuclear","title":"Primary energy sources","text":"summarize existing planned projects normally included optimizationhttps://www.world-nuclear.org/information-library/country-profiles/countries-g-n/india.aspx","code":"# Declaration of commodity NUC <- newCommodity(   name = \"NUC\",    desc = \"Nuclear fuel\",   unit = \"GWh\",    #slice = \"ANNUAL\" deprecated   timeframe = \"ANNUAL\" )  IMP_NUC <- newImport(   name = \"IMP_NUC\",   desc = \"Import of nuclear fuel\",   commodity = \"NUC\",   unit = \"GWh\",   imp = data.frame(     # region = NA, # all regions     price = convert(\"cents/kWh\", \"cr.INR/GWh\", 0.46 * .35)      # price adjusted for 35% efficiency   ),   misc = list(     source = \"https://world-nuclear.org/information-library/economic-aspects/economics-of-nuclear-power.aspx\",     cost = \"fuel cost = 0.46 ¢/kWh\"   ) )  # saving the model objects in repository repo_energy <- add(repo_energy, NUC, IMP_NUC, overwrite = F) repo_energy@data |> names() #>  [1] \"COA\"         \"SUP_COA\"     \"IMP_COA\"     \"OIL\"         \"SUP_OIL\"     #>  [6] \"IMP_OIL\"     \"GAS\"         \"SUP_GAS\"     \"IMP_GAS\"     \"CO2SINK\"     #> [11] \"RES_CO2SINK\" \"BIO\"         \"RES_BIO\"     \"NUC\"         \"IMP_NUC\""},{"path":[]},{"path":"https://ideea-model.github.io/IDEEA/articles/growth.html","id":"gdp-growth","dir":"Articles","previous_headings":"","what":"GDP growth","title":"Growth and demand scenarios","text":"Historic projections [references]","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/growth.html","id":"electric-demand-scenarios","dir":"Articles","previous_headings":"","what":"Electric demand scenarios","title":"Growth and demand scenarios","text":"Historic 2000-2022 (total region available) Projections (2050-2070) scenarios * scenario 1 * scenario 2 * … [references]","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/help.html","id":"convenstions","dir":"Articles","previous_headings":"","what":"Convenstions","title":"Getting help with IDEEA","text":"Due multi-lingual nature IDEEA repository scripts written R, Python, Julia, GAMS, adopted following conventions naming objects functions: - Names functions data objects - Names model objects (‘technologies’, ‘regions’, ‘commodities’, etc.)","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/help.html","id":"ideea-r-package-help","dir":"Articles","previous_headings":"","what":"IDEEA R-package help","title":"Getting help with IDEEA","text":"functions data","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/help.html","id":"report-bugs","dir":"Articles","previous_headings":"","what":"Report bugs","title":"Getting help with IDEEA","text":"[github link]","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/help.html","id":"suggest-features","dir":"Articles","previous_headings":"","what":"Suggest features","title":"Getting help with IDEEA","text":"[github link]","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/help.html","id":"ideea-community-discord-chanel","dir":"Articles","previous_headings":"","what":"IDEEA community Discord chanel","title":"Getting help with IDEEA","text":"https://discord.com/invite/VYAKGRYaaN","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/help.html","id":"ideea-in-switch","dir":"Articles","previous_headings":"","what":"IDEEA in Switch","title":"Getting help with IDEEA","text":"[link Switch]","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/help.html","id":"alternative-models-and-resources","dir":"Articles","previous_headings":"","what":"Alternative models and resources","title":"Getting help with IDEEA","text":"PyPSA OpenMod","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/help.html","id":"faq","dir":"Articles","previous_headings":"","what":"FAQ:","title":"Getting help with IDEEA","text":"IDEEA free? Can use IDEEA research? Can use IDEEA commercial projects? cite IDEEA use ? Can use IDEEA resources build another model?","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/hydrogen.html","id":"green-hydrogen","dir":"Articles","previous_headings":"","what":"Green hydrogen","title":"IDEEA: hydrogen technologies","text":", balancing features hydrogen India - strategy","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://ideea-model.github.io/IDEEA/articles/IDEEA.html","id":"build-electric-power-system-model","dir":"Articles","previous_headings":"","what":"Build electric power system model","title":"IDEEA","text":"","code":"# get the spatial features ideea_sf <- get_ideea_map(nreg = 7, offshore = FALSE)  # select the pre-defined model ideea_elc <- ideea_modules$electricity$reg7_base  ideea_elc$repo_ccstechs$ECOA_CCS_FL@input$group ideea_elc$repo_ccstechs$ECOA_CCS_FL@input$group <- \"a\"  ideea_elc$repo_ccstechs$EGAS_CCS_FL@input$group ideea_elc$repo_ccstechs$EGAS_CCS_FL@input$group <- \"a\"   # create repository for the model repo_elc <- newRepository(\"repo_electricity\") |>   add(     ideea_elc$repo_comm, # commodities     ideea_elc$repo_supply, # primary supply & imports     ideea_elc$ECOA, # coal-fired generators     ideea_elc$EGAS, # gas-fired generators     ideea_elc$CT_EGAS, # limits on gas-fired investments     ideea_elc$ENUC, # nuclear generators     ideea_elc$EHYD, # hydro generators     ideea_elc$WHYD, # hydro capacity factors     ideea_elc$EBIO, # biomass generators     ideea_elc$ESOL, # solar generators     ideea_elc$WSOL, # solar capacity factors     ideea_elc$CT_ESOL, # limits on solar investments     ideea_elc$EWIN, # wind generators     ideea_elc$WWIN, # wind capacity factors     ideea_elc$repo_geoccs, # CCS storage geo-potential     ideea_elc$repo_ccstechs, # CCS technologies     ideea_elc$repo_transmission, # transmission lines     ideea_elc$NO_BY_INV, # no investments in base year     ideea_elc$NO_NEW_NUCLEAR, # no new nuclear construction     ideea_elc$NO_NEW_HYDRO, # no new hydro construction     ideea_elc$DEMELC_BY, # demand, load curve in the base year     ideea_elc$DEMELC_2X # demand growth   ) summary(repo_elc) names(repo_elc)  mod <- newModel(   name = \"mod_electricity\",   repository = repo_elc,   region = ideea_sf$region,   discount = 0.05,   calendar = ideea_elc$full_calendar_d365_h24,   horizon = ideea_elc$horizon_2020_2060_by_10 )"},{"path":"https://ideea-model.github.io/IDEEA/articles/IDEEA.html","id":"solve-base-scenario","dir":"Articles","previous_headings":"","what":"Solve base scenario","title":"IDEEA","text":"","code":"# base year scenario (1 year only) scen_BY <- solve(mod, horizon = newHorizon(2020, rep(1, 1))) summary(scen_BY)  # reference scenario (40 years) with subset of the calendar scen_REF <- solve_model(   mod, name = \"REF\",    solver = solver_options$pyomo_cplex_barrier,   # solver = solver_options$gams_gdx_cplex_parallel,   tmp.del = FALSE,   calendar = ideea_elc$partial_calendar_1day_per_month,   wait = F   ) summary(scen_REF)"},{"path":"https://ideea-model.github.io/IDEEA/articles/IDEEA.html","id":"policy-scenarios","dir":"Articles","previous_headings":"","what":"Policy scenarios","title":"IDEEA","text":"","code":"# CO2 cap scen_CAP <- solve_model(mod, name = \"CAP\",                          # here we can add policy objects                         ideea_elc$STG_BTR,                         ideea_elc$CO2_CAP,                         calendar = ideea_elc$partial_calendar_1day_per_month)"},{"path":"https://ideea-model.github.io/IDEEA/articles/IDEEA.html","id":"reports","dir":"Articles","previous_headings":"","what":"Reports","title":"IDEEA","text":"tbc…","code":"# Collect all time-slices from a scenario all_slices <- scen_CAP@settings@calendar@timetable$slice # Plot \"snapshot\" of an system hourly operation for a particular day/year ideea_snapshot(scen_CAP, YEAR = 2055, SLICE = all_slices[grepl(\"d015\", all_slices)])  ideea_snapshot(scen_CAP, YEAR = 2060,                 SLICE = all_slices[grepl(\"d015\", all_slices)],                return_data = F) +   facet_grid(region~year, scales = \"free_y\")"},{"path":"https://ideea-model.github.io/IDEEA/articles/install.html","id":"install-r","dir":"Articles","previous_headings":"","what":"Install R","title":"IDEEA model installation","text":"R free, open-source software, initially developed statistical computing, currently broad sets powerful tool data manipulation visualization, including mapping. Download base R system (Windows, macOS, Linux) CRAN (https://cloud.r-project.org/) install following installation instructions (https://cloud.r-project.org/). Windows users must also install (RTools)[https://cloud.r-project.org/] version matching R version (current/installed version R R-4.3.* RTools version must RTools 4.3). Installation RTools required able compile packages Windows system, tools already part UNIX-based systems like Linux MacOS.","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/install.html","id":"install-rstudio-recommended","dir":"Articles","previous_headings":"","what":"Install RStudio (recommended)","title":"IDEEA model installation","text":"Integrated Development Environment (IDE) required run IDEEA models, develop conduct study. recommend using RStudio IDE, best integration R R-packages. Download RStudio https://posit.co/download/rstudio-desktop/#download install following installation instructions.","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/install.html","id":"create-rstudio-project","dir":"Articles","previous_headings":"Install RStudio (recommended)","what":"Create RStudio project","title":"IDEEA model installation","text":"often overlooked step new RStudio users creation RStudio project. good practice create project every study, helps keep files scripts one place, avoid conflicts different projects. create project, open RStudio, go File -> New Project... -> New Directory -> New Project specify project name location. create IDEEA_test project Documents/RProjects folder. done, please create new R-markdown file project folder save install_ideea.Rmd.","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/install.html","id":"install-r-packages","dir":"Articles","previous_headings":"","what":"Install R packages","title":"IDEEA model installation","text":"Add R-chunks just created .Rmd file (use + button top right corner RStudio editor), copy-paste code document R-markdown file. script chunk can run pressing Ctrl+Enter Cmd+Enter RStudio editor. install required R-packages IDEEA model.","code":"# install package management library if (!(\"pak\" %in% rownames(installed.packages()))) install.packages(\"pak\") library(\"pak\") # install required packages (if not installed) pkg_install(\"devtools\", upgrade = TRUE) # to compile packages pkg_install(\"tidyverse\", upgrade = TRUE) # packages for data and graphics pkg_install(\"data.table\", upgrade = TRUE) # memory and time-efficient data-frames pkg_install(\"sf\", upgrade = TRUE) # working with GIS/maps pkg_install(\"reticulate\", upgrade = TRUE) # running Python from R # install energyRt and merra2ools pkg_install(\"energyRt/merra2ools\") # (fix version later) pkg_install(\"energyRt/energyRt@v0.50\") # (fix version later) # install IDEEA pkg_install(\"ideea-model/IDEEA@v0.50\")  # GAMS users may want to install `gdxtools` (see GAMS section) # pkg_install(\"lolow/gdxtools\") # Manipulate GDX-files for data exchange # additional packages for visualization and reporting pkg_install(\"cowplot\") pkg_install(\"ggthemes\") pkg_install(\"kableExtra\") pkg_install(\"shiny\") pkg_install(\"shinyWidgets\")"},{"path":"https://ideea-model.github.io/IDEEA/articles/install.html","id":"optimization-software-options","dir":"Articles","previous_headings":"","what":"Optimization software options","title":"IDEEA model installation","text":"least one algebraic modeling languages must installed solve IDEEA models. Bellow step--step guide references install Python, Julia, GLPK, GAMS.","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/install.html","id":"install-python","dir":"Articles","previous_headings":"Optimization software options","what":"Install Python","title":"IDEEA model installation","text":"several ways install Python. common direct installation Python distribution, using Anaconda tool manage Python environments packages. example installs miniconda (minimal version Anaconda) R creates ideea environment required packages. Anaconda miniconda system installation step can omitted.","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/install.html","id":"install-miniconda","dir":"Articles","previous_headings":"Optimization software options > Install Python","what":"Install miniconda","title":"IDEEA model installation","text":"conda package manager can install Python packages software packages. miniconda minimal version Anaconda includes Python conda.","code":"library(reticulate) # run Python from R conda_list() # check if conda is installed if (!is.null(miniconda_path())) {   install_miniconda() # install miniconda   # install_miniconda(update = T, force = T) # re-install miniconda   miniconda_update()   # miniconda_uninstall() # use to uninstall miniconda } miniconda_path() # check the path to miniconda to use in IDEEA & energyRt settings"},{"path":"https://ideea-model.github.io/IDEEA/articles/install.html","id":"create-ideea-environment","dir":"Articles","previous_headings":"Optimization software options > Install Python","what":"Create ideea environment","title":"IDEEA model installation","text":"Create new environment ideea install required Python-packages.","code":"conda_create(\"ideea\", python_version = 3.9) conda_list()  condaenv_exists(\"ideea\") # check if the 'ideea' environment exists use_condaenv(\"ideea\")"},{"path":"https://ideea-model.github.io/IDEEA/articles/install.html","id":"install-python-packages","dir":"Articles","previous_headings":"Optimization software options > Install Python","what":"Install Python packages","title":"IDEEA model installation","text":"IDEEA/energyRt models Python formulated Pyomo open-source optimization modeling language. Pyomo can used different solvers, including open-source GLPK, Cbc, commercial CPLEX, GUROBI, others. example installs Pyomo, GLPK, Cbc, several required packages. IBM CPLEX GUROBI efficient commercial solvers also free academia. Please refer IBM GUROBI installation guides. […] Several mainstream solvers can used Pyomo, installation must done separately every solver/software. Cbc HiGHS powerful open-source solvers, strightforward install Windows make working Pyomo. planning use open-source solvers Windows, consider using Julia instead installation solvers streamlined. plan use IDEEA-Switch version (forthcoming), please also install Switch-model library. test installed ideea environment follow … [tbc]","code":"# general purpose packages, used by IDEEA & energyRt in python models conda_install(\"ideea\", \"pandas\", forge = TRUE) # data manipulation conda_install(\"ideea\", \"scipy\", forge = TRUE) # scientific computing conda_install(\"ideea\", \"rpy2\", forge = TRUE) # R-Python interface conda_install(\"ideea\", \"arrow\", forge = TRUE) # efficient data manipulation and exchange conda_install(\"ideea\", \"datetime\", pip = TRUE) # date-time manipulation # Algebraic modeling language/module Pyomo conda_install(\"ideea\", \"pyomo\", pip = TRUE) # optimization modeling language # Linear solvers conda_install(\"ideea\", \"glpk\", forge = TRUE) # open-source linear solver GLPK conda_install(\"ideea\", \"highspy\", pip = TRUE) # open-source linear solver HiGHS conda_install(\"ideea\", \"pyomo[optional]\", pip = TRUE) # optional solvers conda_install(\"ideea\", \"pybind11\", pip = TRUE) # open-source linear solver HiGHS   # conda_install(\"ideea\", \"coin-or-cbc\", forge = T) # conda_install(\"ideea\", \"cbcpy\", pip = T) # https://pypi.org/project/cbcpy/ # https://ampl.com/products/solvers/open-source-solvers/  # If Cbc installation doesn't work (it is a common issue on Windows for Cbc),  # try to install it from alternative sources: # conda_install(\"ideea\", \"coin-or-cbc\", forge = T) # conda_install(\"ideea\", \"cbcpy\", forge = T) # py_install(\"cbcpy\", envname = \"ideea\", pip = T) conda_install(\"ideea\", \"switch_model\", forge = TRUE)"},{"path":"https://ideea-model.github.io/IDEEA/articles/install.html","id":"install-julia","dir":"Articles","previous_headings":"Optimization software options","what":"Install Julia","title":"IDEEA model installation","text":"Julia modern, high-level, high-performance programming language scientific computing, machine learning, data mining, designed parallelism distributed computation. Julia good choice optimization problems, easy install use. Knowing Julia (Python) required IDEEA users. Julia can used IDEEA package via energyRt solve models. install Julia, download latest version Julia website, install following installation instructions. Windows users advised use winget package manager install Julia Microsoft Store. Mac Linux users download installer compatible systems Julia website. installed, open terminal (command prompt) run Julia REPL typing julia. Julia REPL, install required packages running following commands: commands install Julia packages required run IDEEA models. JuMP package optimization modeling language, HiGHS, Cbc, Clp linear solvers. RCall package used run R Julia, RData exchange data R Julia. Gadfly, DataFrames, CSV, SQLite, Dates general-purpose packages used data-exchange.","code":"winget install julia -s msstore println(\"Julia Version: \", VERSION) import Pkg Pkg.add(\"JuMP\") Pkg.add(\"HiGHS\") Pkg.add(\"Cbc\") Pkg.add(\"Clp\") # Pkg.add(\"CPLEX\") # link to pre-installed CPLEX # Pkg.add(\"Gurobi\") # link to pre-installed Gurobi Pkg.add(\"RData\") Pkg.add(\"RCall\") Pkg.add(\"CodecBzip2\") Pkg.add(\"Gadfly\") Pkg.add(\"DataFrames\") Pkg.add(\"CSV\") Pkg.add(\"SQLite\") Pkg.add(\"Dates\") Pkg.status()  # Pkg.update() # use to update packages"},{"path":"https://ideea-model.github.io/IDEEA/articles/install.html","id":"install-glpkmathprog","dir":"Articles","previous_headings":"Optimization software options","what":"Install GLPK/MathProg","title":"IDEEA model installation","text":"GNU Linear Programming Kit (GLPK) lightwight linear solver embedded language interpreter MathProg (subset AMPL) solve linear programming problems. GLPK good choice small medium-size models, free open-source. install GLPK Windows, download latest version GLPK Windows install following installation instructions. MacOS GLPK can installed homebrew package manager: Ubuntu users can try: Linux systems please refer https://en.wikibooks.org/wiki/GLPK/Linux_OS GNU-GLPK guides.","code":"brew install glpk sudo apt-get install glpk-utils"},{"path":"https://ideea-model.github.io/IDEEA/articles/install.html","id":"install-gams","dir":"Articles","previous_headings":"Optimization software options","what":"Install GAMS","title":"IDEEA model installation","text":"General Algebraic Modeling System (GAMS) modeling language proprietary software mathematical modeling numeric optimization. IDEEA users already GAMS license powerful linear solvers (like CPLEX), plan solve large-scale models regularly, might good option due better time performance model generation stage. Please follow installation instructions GAMS add configuration file (). Also IDEEA energyRt depend gdxtools work GAMS Data Exchange (GDX) files. required essential time performance large datasets.","code":"pak::pkg_install(\"lolow/gdxtools\") # Manipulate GDX-files for data exchange"},{"path":"https://ideea-model.github.io/IDEEA/articles/install.html","id":"additional-datasets","dir":"Articles","previous_headings":"","what":"Additional Datasets","title":"IDEEA model installation","text":"…","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/install.html","id":"ideea-global-options","dir":"Articles","previous_headings":"","what":"IDEEA global options","title":"IDEEA model installation","text":"installation done, recommended create configuration file specific settings system. Location, paths installed software computer- user-specific. information can stored locally loaded IDEEA package. initiated file opened (, open IDE ~\\ideea.r). nex step edit (add paths) uncomment options: edited, save try source calling ideea_global_options(). errors, file can closed. sourced every time IDEEA package load. done! Check “Getting started” test system.","code":"library(IDEEA) ideea_global_options(edit = T) # IDEEA external dataset # set_ideea_extra('...')  # IDEEA solver options # energyRt::set_gams_path('C:/GAMS/...') # energyRt::set_gdxlib_path('C:/GAMS/...') # energyRt::set_gams_path('C:/GAMS/...') # energyRt::set_glpk_path() # energyRt::set_julia_path() # energyRt::set_python_path() # energyRt::set_default_solver(solver_options$julia_highs_barrier)  # Use progress bar # energyRt::set_progress_bar()"},{"path":"https://ideea-model.github.io/IDEEA/articles/install.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"IDEEA model installation","text":"RRStudioGNU Linear Programming Kit (GLPK)Julia Programming LanguageJuMP modeling languagePythonConda DocumentationThe General Algebraic Modeling Language (GAMS)Modeling Language Mathematical Programming (AMPL)","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/karnataka.html","id":"configuration","dir":"Articles","previous_headings":"","what":"Configuration","title":"Karnataka electric power sector capacity expansion model","text":"","code":"tmz <- \"Asia/Kolkata\" # model timezone baseYear <- 2019 # model base year # modYears <- c(baseYear + c(0, 2), seq(2025, 2060, by = 5)) # model years # weaYears <- 2019 # weather years (from MERRA-2)  # Currency conversion INR_Crore_2_USD <- 136825.20 # Google converter, Jan 13, 2021 INR_2_USD <- INR_Crore_2_USD / 1e7 INR_Crore_2_MUSD <- INR_Crore_2_USD/1e6  INR_Lakh_2_MUSD <- INR_Crore_2_MUSD/100 ideea_sf <- get_ideea_map(nreg = 32, offshore = FALSE, ROW = FALSE, rename = TRUE) karnataka_sf <- ideea_sf[ideea_sf$region == \"KA\", ]  plot(ideea_sf[\"region\"], col = NA, reset = F, main = \"Karnataka\") plot(karnataka_sf[\"region\"], col = \"red\", add = T)"},{"path":[]},{"path":"https://ideea-model.github.io/IDEEA/articles/karnataka.html","id":"wind-by-resource-class","dir":"Articles","previous_headings":"Weather classes","what":"Wind (by resource class)","title":"Karnataka electric power sector capacity expansion model","text":"","code":"# generating capacity gen_cap <- ideea_data$karnataka$capacity_MW # wind capacity factors wind_cf <- ideea_data$karnataka$wind_cf # wind and solar average potential estimates merra_CF_mean <- ideea_data$karnataka$merra_CF_mean # wind_loc_sf <- ideea_data$karnataka$wind_loc_sf  (wind_120m <- unique(merra_CF_mean$af120m_class)) #> [1] \"AF20\" \"AF25\" \"AF15\" \"AF30\" \"AF35\" ww <- merra_CF_mean$af120m_class %in% wind_120m ggplot(karnataka_sf) +   geom_sf(aes(),     fill = \"wheat\",     colour = \"white\", alpha = 1, size = .5, show.legend = F   ) +    theme_void() +   # ggplot(merra_CF_mean[ww,]) +   geom_tile(aes(lon, lat, fill = af120m),     data = merra_CF_mean,     inherit.aes = F, alpha = .75, show.legend = T   ) +   scale_fill_distiller(     palette = \"YlGnBu\", name = \"CF 120m\", direction = 1,     limits = c(0.1, NA), na.value = \"grey70\"   ) +   geom_tile(aes(lon, lat),     data = merra_CF_mean[ww, ],      colour = \"red\", fill = NA,     inherit.aes = F, show.legend = T   ) +   geom_sf(fill = NA, colour = \"grey\", alpha = 1, size = .5,            data = karnataka_sf) +    geom_point(aes(lon, lat, size = capacity_mw),              colour = \"red\",              data = ideea_data$karnataka$wind_loc_sf,               inherit.aes = FALSE) +   labs(     title = \"Wind capacity factors and installed capacity in Karnataka\"     # subtitle = \"Wind resource classes and potential locations\",     # caption = \"Source: MERRA-2, WRI, IDEEA\"   ) # theme_ideea_map()     # Create weather-class for every AF-type of the resource summary(wind_cf$wcf_120m) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #> 0.01405 0.21568 0.36705 0.35481 0.47791 0.75000 WWIN_120m <- newRepository(\"WWIN_120m\") for (i in wind_120m) {   ii <- wind_cf$af120m_class == i   WWIN_i <- newWeather(     name = paste0(\"WWIN_\", i),     # desc = \"\",     # unit = \"kWh/kWh_max\",     timeframe = \"HOUR\",     weather = data.frame(       # region = as.character(),       # year = merra_CF_mean$mYear[ii],       slice = wind_cf$slice[ii],       wval = wind_cf$wcf_120m[ii]      )   )   WWIN_120m <- add(WWIN_120m, WWIN_i) } names(WWIN_120m@data) #> [1] \"WWIN_AF20\" \"WWIN_AF25\" \"WWIN_AF15\" \"WWIN_AF30\" \"WWIN_AF35\""},{"path":"https://ideea-model.github.io/IDEEA/articles/karnataka.html","id":"solar-regional-average","dir":"Articles","previous_headings":"Weather classes","what":"Solar (regional average)","title":"Karnataka electric power sector capacity expansion model","text":"","code":"# solar average capacity factors solar_cf <- ideea_data$karnataka$solar_cf  # Create weather-class for solar resource (average) summary(solar_cf$scf) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #> 0.00000 0.00000 0.01139 0.24138 0.48715 1.00000 WSOL_mean <- newWeather(   name = \"WSOL\",   # desc = \"\",   # unit = \"kWh/kWh_max\",   timeframe = \"HOUR\",   weather = data.frame(     slice = solar_cf$slice,     wval = solar_cf$scf    ) )  # gen_cap$cap_MW[grepl(\"Solar\", gen_cap$enSource)] / 1e3 * #   sum(merra_sol_mean$afsol)"},{"path":"https://ideea-model.github.io/IDEEA/articles/karnataka.html","id":"hydro-reservoirs-inflows","dir":"Articles","previous_headings":"Weather classes","what":"Hydro (reservoirs inflows)","title":"Karnataka electric power sector capacity expansion model","text":"","code":"# Inflow and discharge data of reservoirs w_hyd <- ideea_data$karnataka$reservoir |>   filter(year(datetime) %in% baseYear) %>%   mutate(date = as_date(datetime)) %>%   ungroup() %>%   dplyr::select(-datetime) %>%   mutate(slice = dtm2tsl(date, format = \"d365\")) w_hyd[c(1, nrow(w_hyd)),] # accumulated energy -first and last days of the year #>    DISCHARGE_MU EQENERGY_MU INFLOW_MU       date  slice #>           <num>       <num>     <num>     <Date> <char> #> 1:    -28.19596    6133.078  2.625201 2019-01-01   d001 #> 2:    -33.75062    7136.870  8.159480 2019-12-31   d365 sum(w_hyd$INFLOW_MU) # total inflow #> [1] 9773.639 sum(w_hyd$DISCHARGE_MU) # total discharge (!some days are missing in the data-Adjusting Coefficient) #> [1] -8006.358  # Adjust the 3-dams data, adding reservoirs with missing info gen_cap #> # A tibble: 6 × 6 #>    year enSource   cap_MW  gen_MU     af type       #>   <dbl> <chr>       <dbl>   <dbl>  <dbl> <chr>      #> 1  2019 Biomass      134.    86.5 0.0736 biomass    #> 2  2019 Hydro       4665. 14327.  0.351  hydro      #> 3  2019 Net_Import  4133. 20562.  0.568  net_import #> 4  2019 Solar       7038  11524.  0.216  solar      #> 5  2019 Thermal    10379. 16578.  0.182  thermal    #> 6  2019 Wind        4778.  8528.  0.204  wind ii <- grepl(\"Hydro\", gen_cap$enSource) summary(ii) #>    Mode   FALSE    TRUE  #> logical       5       1 gen_cap$gen_MU[ii] #> [1] 14327.19 sum(w_hyd$INFLOW_MU) #> [1] 9773.639 (hyd_adj <- gen_cap$gen_MU[ii] / sum(w_hyd$INFLOW_MU)) # Adjusting Coefficient #> [1] 1.465901  # Hydro   weather class repository  WHYD_AF <- newWeather(\"WHYD_AF\",   desc = \"Exogenous hydro energy inflow\",   region = \"KA\",   timeframe = \"YDAY\",   weather = data.frame(     region = \"KA\",     # year = 2010,     slice = w_hyd$slice,     wval = w_hyd$INFLOW_MU * hyd_adj # assumption   ) )"},{"path":[]},{"path":"https://ideea-model.github.io/IDEEA/articles/karnataka.html","id":"thermal","dir":"Articles","previous_headings":"Generating technologies","what":"Thermal","title":"Karnataka electric power sector capacity expansion model","text":"","code":"gen_cap #> # A tibble: 6 × 6 #>    year enSource   cap_MW  gen_MU     af type       #>   <dbl> <chr>       <dbl>   <dbl>  <dbl> <chr>      #> 1  2019 Biomass      134.    86.5 0.0736 biomass    #> 2  2019 Hydro       4665. 14327.  0.351  hydro      #> 3  2019 Net_Import  4133. 20562.  0.568  net_import #> 4  2019 Solar       7038  11524.  0.216  solar      #> 5  2019 Thermal    10379. 16578.  0.182  thermal    #> 6  2019 Wind        4778.  8528.  0.204  wind ii <- grepl(\"Thermal\", gen_cap$enSource) summary(ii) #>    Mode   FALSE    TRUE  #> logical       5       1 ECOA <- newTechnology(   name = \"ECOA\",   desc = \"Generic Coal-fired power plant, base year\",   # region = ppb$region[ii],   input = list(     comm = \"COA\",     unit = \"GWh\",     combustion = 1   ),   output = list(     comm = \"ELC\",     unit = \"GWh\"   ),   cap2act = 24 * 365,   ceff = list(     comm = c(\"COA\"),     cinp2use = c(.35)   ),   af = list(     af.lo = .2, # aggregated lower bound     rampup = 48, # hours, cold start from 0 to 100, assumption     rampdown = 48 # assumption   ),   afs = list(     slice = \"ANNUAL\",     afs.up = .6, # assumption     afs.lo = .2 # assumption   ),   fixom = list(     # fixom = .05 * 800 # 5% a year of invcost (800 USD/kW)     fixom = convert(\"MUSD/MW\", \"MUSD/GW\", 11.7 * INR_Lakh_2_MUSD)   ),   varom = list(     # varom = 0.01 # USD/kWh - assumption     # convert(\"USD/kWh\", \"MUSD/GWh\", 1)     varom = convert(\"USD/kWh\", \"MUSD/GWh\", 0.6 * INR_2_USD)    ),   invcost = list(     invcost = convert(\"MUSD/MW\", \"MUSD/GW\", 8.02 * INR_Crore_2_MUSD)   ),   capacity = data.frame(     region = \"KA\",     year = c(rep(baseYear, sum(ii)), rep(2040, sum(ii))),     stock = c(gen_cap$cap_MW[ii] / 1e3, 0.7 * gen_cap$cap_MW[ii] / 1e3) # assumption   ),   end = list(     end = 2010   ),   olife = list(     olife = 25   ),   timeframe = \"HOUR\" ) draw(ECOA)"},{"path":"https://ideea-model.github.io/IDEEA/articles/karnataka.html","id":"hydro","dir":"Articles","previous_headings":"Generating technologies","what":"Hydro","title":"Karnataka electric power sector capacity expansion model","text":"","code":"ii <- grepl(\"Hydro\", gen_cap$enSource) stopifnot(sum(ii) == 1) # check EHYD <- newTechnology(   name = \"EHYD\",   desc = \"Hydro power plants\",   # region = ppb$region[ii],   region = \"KA\",   input = list(     comm = \"HYD\",     unit = \"GWh\",     combustion = 0   ),   output = list(     comm = \"ELC\",     unit = \"GWh\"   ),   # aux = list(acomm = \"DAM\"),   cap2act = 24 * 365,   # ceff = list(   #   comm = c(\"HYD\"),   #   cinp2use = c(1)   # ),   # aeff = data.frame(   #   acomm = \"DAM\",   #   comm = \"HYD\",   #   cinp2ainp  = 1   # ),   af = list(     af.lo = .1, # aggregated lower bound     # rampup = 4, # hours, cold start from 0 to 100, assumption     rampdown = 8 # assumption   ),   # af = list(   #   # region = ppb$region[ii],   #   # slice = ,   #   af.fx = ppb$af[ii]   # ),   fixom = list(     fixom = convert(\"MUSD/MW\", \"MUSD/GW\", 20 * INR_Lakh_2_MUSD)   ),   # varom = list(   #   varom =   # ),   invcost = list(     # year = 2010,     invcost = convert(\"MUSD/MW\", \"MUSD/GW\", 8.02 * INR_Crore_2_MUSD)   ),   capacity = data.frame(     region = \"KA\",     year = c(rep(baseYear, sum(ii)), rep(2060, sum(ii))),     stock = c(gen_cap$cap_MW[ii] / 1e3, gen_cap$cap_MW[ii] / 1e3)   ),   # start = list(   #   start = 2060   # ),   end = list(     end = 2010   ),   olife = list(     olife = 40   ),   timeframe = \"HOUR\" ) draw(EHYD)"},{"path":"https://ideea-model.github.io/IDEEA/articles/karnataka.html","id":"solar","dir":"Articles","previous_headings":"Generating technologies","what":"Solar","title":"Karnataka electric power sector capacity expansion model","text":"","code":"ii <- grepl(\"Solar\", gen_cap$enSource) stopifnot(sum(ii) == 1) # check ESOL <- newTechnology(   name = \"ESOL\",   desc = \"Utility Scale Solar PV\",   # region = \"AZ\",   input = list(     comm = \"SOL\",     unit = \"GWh\"   ),   output = list(     comm = \"ELC\",     unit = \"GWh\"   ),   cap2act = 365 * 24,   af = list(     af.fx = 1 # forcing output when resource is available   ),   weather = list(     weather = \"WSOL\",     waf.fx = 1 # weather factor (multiplier) will be applied to af.fx   ),   fixom = list(     # fixom = 10 # assumed, 1% of investment costs a year     fixom = convert(\"MUSD/MW\", \"MUSD/GW\", 4.5 * INR_Lakh_2_MUSD)   ),   invcost = list(     # Assuming 1$/Watt     # https://www.nrel.gov/news/press/2017/nrel-report-utility-scale-solar-pv-system-cost-fell-last-year.html     # invcost = 1000 # convert(\"USD/W\", \"MUSD/GW\", 1)      invcost = convert(\"MUSD/MW\", \"MUSD/GW\", 3.4 * INR_Crore_2_MUSD)   ),    capacity = data.frame(     region = \"KA\",     year = c(rep(baseYear, sum(ii)),               rep(2040, sum(ii)),              rep(2050, sum(ii))),     stock = c(gen_cap$cap_MW[ii] / 1e3,                0.8 * gen_cap$cap_MW[ii] / 1e3,               0 * gen_cap$cap_MW[ii])   ),   # start = list(   #   start = 2017   # ),   # end = list(end = 2000),   olife = list(     olife = 25   ) ) draw(ESOL) # bulk solar resource sol_max_GW <- ideea_data$karnataka$solar_max_GW # Limits on solar total capacity CSOL_UP <- newConstraintS(   name = \"CSOL_UP\",   eq = \"<=\",   type = \"capacity\",   for.each = data.frame(     year = NA,     tech = \"ESOL\",     region = \"KA\"     # region = reg_area$region   ),   rhs = data.frame(     # year = modYears,     tech = \"ESOL\",     region = sol_max_GW$region,     # up to 2% of territory per region     rhs = 0.02 * round(sol_max_GW$max_GW, 1e-20)    ),   defVal = 1e-20 # to avoid dropping zeros in some solvers )"},{"path":"https://ideea-model.github.io/IDEEA/articles/karnataka.html","id":"wind","dir":"Articles","previous_headings":"Generating technologies","what":"Wind","title":"Karnataka electric power sector capacity expansion model","text":"","code":"ii <- grepl(\"Wind\", gen_cap$enSource) summary(ii) #>    Mode   FALSE    TRUE  #> logical       5       1 EWIN <- newTechnology(   name = \"EWIN\",   desc = \"Onshore wind farm\",   # WIN10_AF@region, # Limiting to regions with available resource   input = list(     comm = \"WIN\",     unit = \"GWh\",     combustion = 0   ),   output = list(     comm = \"ELC\",     unit = \"GWh\"   ),   cap2act = 365 * 24,   af = list(     af.fx = 1 # forcing output when resource is available   ),   weather = list(     weather = \"WWIN\", # assumption     waf.fx = c(1)     # waf.up = c(1) #   ),   fixom = list(     # fixom = 15 # Assumed, 1% a year     fixom = convert(\"MUSD/MW\", \"MUSD/GW\", 8 * INR_Lakh_2_MUSD)   ),   invcost = list(     # Assuming 1.5$/Watt     # https://www.irena.org/-/media/Files/IRENA/Agency/Publication/2018/Jan/IRENA_2017_Power_Costs_2018.pdf     # invcost = 1500 #     invcost = convert(\"MUSD/MW\", \"MUSD/GW\", 6 * INR_Crore_2_MUSD)        ),   capacity = data.frame(     region = \"KA\",     year = c(rep(baseYear, sum(ii)),               rep(2040, sum(ii)),              rep(2050, sum(ii))),     stock = c(gen_cap$cap_MW[ii] / 1e3,                0.8 * gen_cap$cap_MW[ii] / 1e3,               0 * gen_cap$cap_MW[ii])   ),   # start = list(   #   start = 2017   # ),   end = list(end = 2000),   olife = list(     olife = 25   ) ) draw(EWIN) EWIN_120m <- newRepository(\"EWIN_120m\") for (i in 1:length(WWIN_120m@data)) {   wName <- WWIN_120m@data[[i]]@name   tName <- gsub(\"WWIN_\", \"EWIN_\", wName)   EWIN_i <- newTechnology(     name = tName,     desc = \"Utility Scale Solar PV\",     # region = \"AZ\",     input = list(       comm = \"SOL\",       unit = \"GWh\"     ),     output = list(       comm = \"ELC\",       unit = \"GWh\"     ),     cap2act = 365 * 24,     af = list(       af.fx = 1 # forcing output when resource is available     ),     weather = list(       weather = wName,       waf.fx = 1 # weather factor (multiplier) will be applied to af.fx     ),     # fixom = list(     #   fixom = 10 # assumed, 1% of investment costs a year     # ),     invcost = list(       # Assuming 1$/Watt       # https://www.nrel.gov/news/press/2017/nrel-report-utility-scale-solar-pv-system-cost-fell-last-year.html       invcost = 1000 # convert(\"USD/W\", \"MUSD/GW\", 1)     ),     # start = list(     #   start = 2017     # ),     # end = list(end = 2030),     olife = list(       olife = 25     )   )   EWIN_120m <- add(EWIN_120m, EWIN_i)   # draw(EWIN) }  # estimated bulk wind resource win_max_GW <- ideea_data$karnataka$wind_max_GW # Limits on wind total capacity CWIN_UP <- newConstraintS(   name = \"CWIN_UP\",   eq = \"<=\",   type = \"capacity\",   for.each = data.frame(     year = NA,     tech = paste0(\"EWIN_\", win_max_GW$af120m_class),     region = win_max_GW$region   ),   rhs = data.frame(     year = NA,     tech = paste0(\"EWIN_\", win_max_GW$af120m_class),     region = win_max_GW$region,     rhs = 0.1 * round(win_max_GW$max_GW, 1e-20) # up to 10% of territory per region   ),   defVal = 1e-20 # to avoid dropping zeros in some solvers )"},{"path":"https://ideea-model.github.io/IDEEA/articles/karnataka.html","id":"commodities","dir":"Articles","previous_headings":"","what":"Commodities","title":"Karnataka electric power sector capacity expansion model","text":"","code":"ELC <- newCommodity(\"ELC\", timeframe = \"HOUR\") CO2 <- newCommodity(\"CO2\", timeframe = \"ANNUAL\") SOL <- newCommodity(\"SOL\", timeframe = \"ANNUAL\") WIN <- newCommodity(\"WIN\", timeframe = \"ANNUAL\") WIF <- newCommodity(\"WIF\", timeframe = \"ANNUAL\")  UHV <- newCommodity(   name = \"UHV\",   desc = \"Ultra High Voltage electricity\",   timeframe = \"HOUR\" )  COA <- newCommodity(   name = \"COA\",   desc = \"All coals\",   # emis = list( #   #   comm = \"CO2\", #   #   unit = \"kt/GWh\", #   #   mean = convert(\"kt/PJ\", \"kt/GWh\", 100) #   # ),   timeframe = \"ANNUAL\" )  GAS <- newCommodity(   name = \"GAS\",   desc = \"Natural gas\",   timeframe = \"ANNUAL\" )  BIO <- newCommodity(   name = \"BIO\",   desc = \"Biomass\",   timeframe = \"ANNUAL\" )  HYD <- newCommodity(   name = \"HYD\",   desc = \"Hydro energy\",   timeframe = \"YDAY\" )  # DAM <- newCommodity( #   name = 'DAM', #   desc = \"Hydro energy from Dam\", # Auxiliary/artificial #   timeframe = \"YDAY\")   NUC <- newCommodity(   name = \"NUC\",   desc = \"Nuclear energy\",   timeframe = \"ANNUAL\" )"},{"path":"https://ideea-model.github.io/IDEEA/articles/karnataka.html","id":"demand","dir":"Articles","previous_headings":"","what":"Demand","title":"Karnataka electric power sector capacity expansion model","text":"","code":"dem_baseYear <- ideea_data$karnataka$load_curve |>   filter(year == baseYear)  # projected demand growth dem_last_year <- dem_baseYear %>%   mutate(     year = 2070,      MWh = 5 * MWh) # assume 5X growth from 2019 to 2070 dem_modYear <- bind_rows(dem_baseYear, dem_last_year)  #Demand class repository  DEM_ELC_DH <- newDemand(   name = \"DEM_ELC_DH\",   desc = \"Demand by hours and year-days, full year\",   commodity = \"ELC\",   unit = \"GWh\",   dem = data.frame(     year = dem_modYear$year,     region = \"KA\",     slice = dem_modYear$slice,     dem = round(dem_modYear$MWh / 1e3, 3)   ) )  # Check dim(DEM_ELC_DH@dem) #> [1] 17472     4 dim(DEM_ELC_DH@dem)[1] / 365 / 24 #> [1] 1.994521  # DEM_ELC_DH@dem[is.na(DEM_ELC_DH@dem$dem), ] # check for missing values"},{"path":"https://ideea-model.github.io/IDEEA/articles/karnataka.html","id":"supply","dir":"Articles","previous_headings":"","what":"Supply","title":"Karnataka electric power sector capacity expansion model","text":"","code":"RES_SOL <- newSupply(   name = \"RES_SOL\",   desc = \"Terrestrial solar radiation\",   commodity = \"SOL\",   unit = \"GWh\"   # slice = \"ANNUAL\" )  RES_WIN <- newSupply(   name = \"RES_WIN\",   desc = \"Onshore wind\",   commodity = \"WIN\",   # region = unique(wnd_af10$region),   unit = \"GWh\"   # slice = \"ANNUAL\" )  # RES_WFF <- newSupply( #   name = \"RES_WFF\", #   desc = \"Offshore wind - maximum potential\", #   commodity = \"WFF\", #   region = unique(wndf_af10$region), #   unit = \"GWh\", #   slice = \"ANNUAL\" # )  RES_HYD <- newSupply(   name = \"RES_HYD\",   desc = \"Hydro-resource\",   commodity = \"HYD\",   # slice = \"YDAY\",   weather = data.frame(     weather = \"WHYD_AF\",     wava.fx = 1   ),   availability = list(ava.fx = 1) )  SUPNUC <- newSupply(   name = \"SUPNUC\",   commodity = \"NUC\",   unit = \"GWh\",   availability = list(     # ava.up = convert(\"GWh\", \"PJ\", 20*24*365),     # http://www.world-nuclear.org/information-library/economic-aspects/economics-of-nuclear-power.aspx     cost = convert(\"USD/kWh\", \"MUSD/GWh\", .39 / 100)   )   # slice = \"ANNUAL\" )  SUPCOA <- newSupply(   name = \"SUPCOA\",   commodity = \"COA\",   desc = \"Simplified coal supply\",   availability = list(     # cost = convert(\"USD/tce\", \"MUSD/GWh\", 70 / .7)     cost = convert(\"USD/tce\", \"MUSD/GWh\", 6000 * INR_2_USD / 0.7) # 0.7 tone -> tce   )   # slice = \"ANNUAL\" )  # 1,000 Cubic Feet Of Natural Gas to Therms (u.s.) = 10.0024 # 4 USD/cu.ft ~= 0.4 USD/therm SUPGAS <- newSupply(   name = \"SUPGAS\",   desc = \"Simplified gas supply\",   commodity = \"GAS\",   availability = list(     cost = convert(\"USD/therm\", \"MUSD/GWh\", 0.5)   )   # slice = \"ANNUAL\" )  SUPOIL <- newSupply(   name = \"SUPOIL\",   desc = \"Simplified oil supply\",   commodity = \"OIL\",   availability = list(     cost = convert(\"USD/therm\", \"MUSD/GWh\", 0.5)   )   # slice = \"ANNUAL\" )  SUPBIO <- newSupply(   name = \"SUPBIO\",   desc = \"Simplified Biomass supply\",   commodity = \"BIO\",   availability = list(     cost = convert(\"USD/therm\", \"MUSD/GWh\", 0.4) # assumption   )   # slice = \"ANNUAL\" )"},{"path":[]},{"path":"https://ideea-model.github.io/IDEEA/articles/karnataka.html","id":"hydro-reservoirs","dir":"Articles","previous_headings":"Energy storage","what":"Hydro reservoirs","title":"Karnataka electric power sector capacity expansion model","text":"","code":"generation_hourly <- ideea_data$karnataka$generation_hourly # w_hyd # summary(w_hyd$DISCHARGE_MU) # summary(w_hyd$INFLOW_MU) # summary(w_hyd$EQENERGY_MU) #  # sum(w_hyd$DISCHARGE_MU) # sum(w_hyd$INFLOW_MU) # sum(w_hyd$EQENERGY_MU) #  #  # ii <- grepl(\"(d001)|(d365)\", w_hyd$slice) # sum(ii) # w_hyd[ii, ] #  STGHYD_dat <- tibble(   stock = max(abs(w_hyd$EQENERGY_MU)),   cout.up = -min(w_hyd$DISCHARGE_MU) / stock * 365 # annual generation per GW of storage capacity ) STGHYD_dat #> # A tibble: 1 × 2 #>   stock cout.up #>   <dbl>   <dbl> #> 1 8424.    10.1  ii <- grepl(\"(d001)\", w_hyd$slice) sum(ii) #> [1] 1 STGHYD <- newStorage(   name = \"STGHYD\",   commodity = \"HYD\",   desc = \"Hydro reservoirs\",   cap2stg = 1, #   # aux = list(acomm = \"DAM\"),   olife = list(olife = 25),   # invcost = list(   #   # See IRENA 2030 (from 77 to 574, p.77)   #   invcost = convert(\"USD/kWh\", \"MUSD/GWh\", 200)   #   ),   af = data.frame(     # inpeff = .99, # assumed efficiency of charging     # stgeff = .99, # assumed efficiency of storing energy (annual)     # outeff = .99, # discharge efficiency     cout.up = STGHYD_dat$cout.up * hyd_adj     # cout.up = 12.1   ),   # aeff = data.frame(   #   acomm = \"DAM\",   #   out2aout = 1   # ),   capacity = data.frame(     region = \"KA\",     # year = modYears,     stock = STGHYD_dat$stock * hyd_adj     # slice = w_hyd$slice[ii],     # charge = w_hyd$EQENERGY_MU[ii]   ),   end = list(end = 2010) )  # WHYD_AF1 <- WHYD_AF # WHYD_AF1@weather$wval[1] <- w_hyd$EQENERGY_MU[ii]  CHYD2DAM <- newConstraint(   name = \"CHYD2DAM\",   eq = \"==\",   for.each = list(     # year = modYears,     year = NA,     region = \"KA\",     slice = ideea_modules$calendars$calendar_d365_h24@timeframes$YDAY   ),   tr1 = list(     variable = \"vSupOut\",     for.sum = list(sup = \"RES_HYD\")   ),   tr2 = list(     variable = \"vStorageInp\",     for.sum = list(stg = \"STGHYD\"), mult = -1   ),   rhs = data.frame(     # year = rep(modYears, each = length(timeslices365$YDAY)),     year = NA,     region = \"KA\",     slice = ideea_modules$calendars$calendar_d365_h24@timeframes$YDAY,     # slice = rep(timeslices365$YDAY, length(modYears)),     rhs = 1e-20   ),   defVal = 1e-20 )  CDAM2EHYD <- newConstraint(   name = \"CDAM2EHYD\",   eq = \"==\",   for.each = list(     # year = modYears,     year = NA,     region = \"KA\"     # slice = timeslices365$YDAY   ),   tr1 = list(     variable = \"vStorageOut\",     for.sum = list(stg = \"STGHYD\",                    ideea_modules$time_tables$d365_h24$YDAY)   ),   tr2 = list(     variable = \"vTechInp\",     for.sum = list(tech = \"EHYD\",                    ideea_modules$time_tables$d365_h24$YDAY),      mult = -1   ),   rhs = data.frame(     # year = rep(modYears, each = length(timeslices365$YDAY)),     # year = modYears,     year = NA,     region = \"KA\",     # slice = rep(timeslices365$YDAY, length(modYears)),     rhs = 1e-20   ),   defVal = 1e-20 )   CHYDLEV <- newConstraint(   name = \"CHYDLEV\",   for.each = data.frame(     # year = modYears,     year = NA,     region = \"KA\",     slice = ideea_modules$calendars$calendar_d365_h24@timeframes$YDAY     ),   vrb = list(     variable = 'vStorageStore',     for.sum = list(stg = 'STGHYD')),   eq = \">=\",   rhs = data.frame(     # year = modYears,     year = NA,     region = \"KA\",     slice = ideea_modules$calendars$calendar_d365_h24@timeframes$YDAY,     rhs = min(w_hyd$EQENERGY_MU)   ),   defVal = 1e-20 )"},{"path":"https://ideea-model.github.io/IDEEA/articles/karnataka.html","id":"batteries","dir":"Articles","previous_headings":"Energy storage","what":"Batteries","title":"Karnataka electric power sector capacity expansion model","text":"","code":"STGBTR <- newStorage(   name = \"STGBTR\",   commodity = \"ELC\",   desc = \"Generic grid-integrated intraday storage (battery)\",   cap2stg = 1, #   olife = list(olife = 25),   end = list(end = baseYear),   invcost = list(     # See IRENA 2030 (from 77 to 574, p.77)     invcost = convert(\"USD/kWh\", \"MUSD/GWh\", 300)   ),   seff = data.frame(     inpeff = 0.8 # assumed efficiency of charging     # stgeff = 0.9 # assumed efficiency of storing energy (annual)     # outeff = 1 # discharge efficiency   ) ) # STGBTR@varom"},{"path":"https://ideea-model.github.io/IDEEA/articles/karnataka.html","id":"trade","dir":"Articles","previous_headings":"","what":"Trade","title":"Karnataka electric power sector capacity expansion model","text":"(interregional export/import, exogenous)","code":"EIMP1 <- newImport(   name = \"EIMP\",   desc = \"Demand curtailments, electricity import at high price (to identify needs for back-up techs such as biomass)\",   commodity = \"ELC\",   imp = list(     price = convert(\"USD/kWh\", \"MUSD/GWh\", 1) # USD per kWh, marginal price   ) )  EIMP01 <- EIMP1 EIMP01@imp$price <- .1 * EIMP1@imp$price  EIMP10 <- EIMP1 EIMP10@imp$price <- 10 * EIMP1@imp$price  unique(gen_cap$enSource) #> [1] \"Biomass\"    \"Hydro\"      \"Net_Import\" \"Solar\"      \"Thermal\"    #> [6] \"Wind\" unique(generation_hourly$type) #> [1] \"biomass\" \"export\"  \"hydro\"   \"import\"  \"solar\"   \"thermal\" \"wind\" ii <- year(generation_hourly$date) %in% baseYear &   grepl(\"(ex|im)port\", generation_hourly$type, ignore.case = T) unique(generation_hourly[ii, ]$type) #> [1] \"export\" \"import\" generation_hourly[ii, ] #>                       date  hour   type      GWh #>                     <POSc> <int> <char>    <num> #>     1: 2019-01-01 00:00:00     1 export -1.39000 #>     2: 2019-01-01 00:00:00     1 import  3.46824 #>     3: 2019-01-01 01:00:00     2 export -1.38100 #>     4: 2019-01-01 01:00:00     2 import  3.38224 #>     5: 2019-01-01 02:00:00     3 export -1.42700 #>    ---                                           #> 17516: 2019-12-31 21:00:00    22 import  4.11719 #> 17517: 2019-12-31 22:00:00    23 export -1.71200 #> 17518: 2019-12-31 22:00:00    23 import  3.99319 #> 17519: 2019-12-31 23:00:00    24 export -1.73500 #> 17520: 2019-12-31 23:00:00    24 import  3.83219  trade <- generation_hourly[ii, ] %>%   pivot_wider(names_from = type, values_from = GWh) %>%   mutate(slice = dtm2tsl(date), .before = hour)  IMPORT <- newImport(   name = \"IMPORT\",   commodity = \"ELC\",   imp = data.frame(     slice = trade$slice,     imp.fx = trade$import   ) ) dim(IMPORT@imp) #> [1] 8760    7  EXPORT <- newExport(   name = \"EXPORT\",   commodity = \"ELC\",   exp = data.frame(     slice = trade$slice,      exp.fx = -trade$export   ) ) dim(EXPORT@exp) #> [1] 8760    7"},{"path":"https://ideea-model.github.io/IDEEA/articles/karnataka.html","id":"additional-constraints","dir":"Articles","previous_headings":"Trade","what":"Additional constraints","title":"Karnataka electric power sector capacity expansion model","text":"","code":"# No new capacity CNCAP0 <- newConstraint(   name = \"CNCAP0\",   eq = \"==\",   # for.each = data.frame(   #   # year = modYears,   #   # tech = \"ESOL\",   #   region = \"KA\"   # ),   tr1 = list(     variable = \"vTechNewCap\"     # for.sum = list(sup = \"RES_HYD\")   ),   rhs = data.frame(     rhs = 1e-100   ),   defVal = 1e-100 )"},{"path":"https://ideea-model.github.io/IDEEA/articles/karnataka.html","id":"the-model","dir":"Articles","previous_headings":"","what":"The model","title":"Karnataka electric power sector capacity expansion model","text":"","code":"# Repository with all the data-objects reps <- newRepository(   name = \"main_repository\",   # Commodities   ELC, SOL, WIN, HYD, COA, CO2, # DAM, WIF,    # Resources (supply)   RES_SOL, RES_WIN, RES_HYD,   SUPCOA,   # SUPBIO,   # Weather factors   WHYD_AF,   WSOL_mean,    WWIN_120m,   # Generating technologies   ESOL,    # EWIN,   EWIN_120m,   # ESOL_repo@data[[1]],   # EWIN_repo@data[[1]],   EHYD,   ECOA,   # Storage   STGHYD,   STGBTR,   CHYDLEV,   # Exogenous interregional trade   IMPORT,   EXPORT,   # Hydro dam operation constraints   CHYD2DAM,   CDAM2EHYD,   # demand   DEM_ELC_DH,   # curtailing demand in case of high marginal costs   EIMP10  )  summary(reps) #>  commodity constraint     demand     export     import    storage     supply  #>          6          3          1          1          2          2          4  #> technology    weather  #>          8          7 names(reps) #>  [1] \"ELC\"        \"SOL\"        \"WIN\"        \"HYD\"        \"COA\"        #>  [6] \"CO2\"        \"RES_SOL\"    \"RES_WIN\"    \"RES_HYD\"    \"SUPCOA\"     #> [11] \"WHYD_AF\"    \"WSOL\"       \"WWIN_AF20\"  \"WWIN_AF25\"  \"WWIN_AF15\"  #> [16] \"WWIN_AF30\"  \"WWIN_AF35\"  \"ESOL\"       \"EWIN_AF20\"  \"EWIN_AF25\"  #> [21] \"EWIN_AF15\"  \"EWIN_AF30\"  \"EWIN_AF35\"  \"EHYD\"       \"ECOA\"       #> [26] \"STGHYD\"     \"STGBTR\"     \"CHYDLEV\"    \"IMPORT\"     \"EXPORT\"     #> [31] \"CHYD2DAM\"   \"CDAM2EHYD\"  \"DEM_ELC_DH\" \"EIMP\"  full_calendar_d365_h24 <- IDEEA::ideea_modules$calendars$calendar_d365_h24  # model-class object mod <- newModel(   name = \"KA\",   desc = \"Karnataka electricity model\",   ## in case of infeasibility, `dummy` variables can be added   # debug = data.frame(#comm = \"ELC\",   #                    dummyImport = 1e6,   #                    dummyExport = 1e6),   region = \"KA\",   discount = 0.05,   calendar = full_calendar_d365_h24,   horizon = newHorizon(period = baseYear:2070,                         intervals = c(1, 3, rep(5, 8)),                         mid_is_end = TRUE),   data = reps )  # check model horizon # getHorizon(mod)  # (optional) the model info {mod@desc <- \" Karnataka power sector, renewables balancing version, 1 region, 1 hour resolution, 3 types of renewables,  2 types of storages.\"}"},{"path":[]},{"path":"https://ideea-model.github.io/IDEEA/articles/karnataka.html","id":"base-year-check","dir":"Articles","previous_headings":"Scenarios","what":"Base-year check","title":"Karnataka electric power sector capacity expansion model","text":"tbc…","code":"# set_progress_bar(\"progress\") set_progress_bar(\"bw\") # 1. Interpolation of parameters # scen_KA_1Y <- interpolate_model(mod, name = \"scen_KA_1Y\", desc = \"\") horizon_BY <- newHorizon(period = baseYear, intervals = 1) # getHorizon(mod) scen_KA_1Y <- interpolate(mod, name = \"scen_KA_1Y\", CNCAP0, horizon_BY) # scen_KA_1Y@path  scen_KA_1Y <- write_script(   scen_KA_1Y,    solver = solver_options$julia_highs   # solver = solver_options$gams_gdx_cplex_parallel   )  # scen_KA_1Y@misc$tmp.dir scen_KA_1Y <- solve_scenario(scen_KA_1Y, wait = T) scen_KA_1Y <- read(scen_KA_1Y) # save Karnataka model to IDEEA repository"},{"path":"https://ideea-model.github.io/IDEEA/articles/reports.html","id":"analysis-of-the-model-output","dir":"Articles","previous_headings":"","what":"Analysis of the model output","title":"Reports","text":"example report can generated model output, using results IDEEA electricity model.","code":"library(IDEEA) library(tidyverse) library(sf)"},{"path":"https://ideea-model.github.io/IDEEA/articles/reports.html","id":"load-the-model-output","dir":"Articles","previous_headings":"Analysis of the model output","what":"Load the model output","title":"Reports","text":"use pre-saved results IDEEA electricity model, 5 32 regions, described vignette(\"electricity\").","code":"ideea_scenarios_list()  # load reference scenario load_scenario(   file.path(ideea_scenarios(),              \"CAP_IDEEA_ELC_reg32_d365_h24_2060\"             # \"REF_IDEEA_ELC_reg32_d365_h24_2060\"             )   ) # load carbon constrained scenario load_scenario(   file.path(ideea_scenarios(),              \"REF_IDEEA_ELC_reg32_d365_h24_Y2050\"             # \"CAP_IDEEA_ELC_reg32_d365_h24_2060\"             )   )  # combine scenarios in one list for comparison sns <- list(   # REF_2060 = .scen$REF,   CAP_2060 = .scen$CAP   ) # quick check summary(.scen$REF) summary(.scen$CAP)  summary(sns) # list with presolved IDEEA scenarios"},{"path":[]},{"path":"https://ideea-model.github.io/IDEEA/articles/reports.html","id":"objective","dir":"Articles","previous_headings":"Analysis of the model output > Compare the results","what":"Objective","title":"Reports","text":"Objective value model (minimized cost)","code":"getData(sns, \"vObjective\", merge = TRUE)"},{"path":"https://ideea-model.github.io/IDEEA/articles/reports.html","id":"installed-capacity","dir":"Articles","previous_headings":"Analysis of the model output > Compare the results","what":"Installed capacity","title":"Reports","text":"","code":"vTechCap <- getData(   scen = sns,    name = c(\"vTechCap\"), # capacity variable of technologies   tech_ = \"^E\", # select only electricity generators (start with \"E\")   process = TRUE, # use unified set-name for all processes (rename 'tech' -> 'process')   digits = 1, # round to 2 digits   drop.zeros = T, # drop zero values   merge = TRUE # merge tables   ) |>   drop_process_cluster() |> # erase cluster from process name   drop_process_vintage() # erase vintage-year from process name  vTechCap_conv <- vTechCap |>   filter(grepl(\"ELC2EDC|EDC2ELC\", process)) # converters  vTechCap_gen <- vTechCap |>   anti_join(vTechCap_conv, by = \"process\") # keep only generators  vStorageCap <- getData(   scen = sns,    name = c(\"vStorageCap\"), # capacity variables of storage technologies   # tech_ = \"^S\", # select only storage technologies (start with \"S\")   process = TRUE, # use unified set-name for all processes (rename 'tech' -> 'process')   digits = 1, # round to 2 digits   drop.zeros = T, # drop zero values   merge = TRUE # merge tables   ) |>    drop_process_vintage() # erase vintage-year from process name  # combine technologies and storage vCap <- bind_rows(vTechCap, vStorageCap)  vCap$process |> unique()"},{"path":"https://ideea-model.github.io/IDEEA/articles/reports.html","id":"capacity-maps","dir":"Articles","previous_headings":"Analysis of the model output > Compare the results","what":"Capacity maps","title":"Reports","text":"","code":"ideea_sf <- get_ideea_map(nreg = 32)  vTechCap_gen_sf <- ideea_sf |>   right_join(vTechCap_gen, by = c(\"reg32\" = \"region\"),              relationship = \"many-to-many\")   ggplot() +   geom_sf(fill = \"grey\", data = ideea_sf) +   geom_sf(aes(fill = value), data = vTechCap_sf) +   scale_fill_viridis_c(option = \"H\", transform = \"sqrt\", name = \"GW\") +   facet_wrap(~process) +   theme_ideea_map()"},{"path":"https://ideea-model.github.io/IDEEA/articles/reports.html","id":"transmission-capacity","dir":"Articles","previous_headings":"Analysis of the model output > Compare the results","what":"Transmission capacity","title":"Reports","text":"","code":"vTradeCap <- getData(sns, \"vTradeCap\", merge = TRUE, process = T,                      digits = 1, drop.zeros = T)  tra_lines_coord <- ideea_data$transmission[[regN]] |>   filter(case == \"newlines_v01\") |>   select(matches(\"region|lon|lat|trd_name\"))  vTradeCap_coord <- vTradeCap |>    left_join(tra_lines_coord,              by = c(\"process\" = \"trd_name_ac\"),              relationship = \"many-to-many\") |>    select(-trd_name_dc) |>   as.data.table() |>   rows_patch(     select(       rename(tra_lines_coord, process = trd_name_dc),       -trd_name_ac     ), by = c(\"process\"), unmatched = \"ignore\") |>   mutate(     type = str_extract(process, \"HVAC|HVDC\"),   ) |>   as.data.table() ggplot() +   geom_sf(data = ideea_sf, fill = \"wheat\") +   geom_segment(     aes(       x = lon.x, y = lat.x, xend = lon.y, yend = lat.y,       linewidth = value, color = type     ),     # color = \"dodgerblue\",      lineend = \"round\", alpha = .75,     data = filter(vTradeCap_coord, value >= 1)   ) +   # geom_point(aes(lon, lat), data = points_coord_r32, color = \"red\") +   labs(x = \"\", y = \"\") +   facet_grid(year~scenario) +   theme_ideea_map()"},{"path":"https://ideea-model.github.io/IDEEA/articles/reports.html","id":"generation-mix","dir":"Articles","previous_headings":"Analysis of the model output > Compare the results","what":"Generation mix","title":"Reports","text":"","code":"vTechOut_ELC <- getData(sns, \"vTechOut\", tech_ = \"^E\", process = T, digits = 2,                         drop.zeros = TRUE, merge = TRUE) |>   drop_process_cluster() |>   drop_process_vintage()  vTechOut_ELC_year <- vTechOut_ELC |>   group_by(scenario, process, year) |>   summarise(TWh = sum(value) / 1e3, .groups = \"drop\") |>   filter(!process %in% c(\"ELC2EDC\", \"EDC2ELC\")) # drop converters  ggplot(vTechOut_ELC_year) +   geom_bar(aes(x = scenario, y = TWh, fill = process), stat = \"identity\") +   scale_fill_viridis_d(option = \"H\", direction = -1) +   theme_bw()"},{"path":[]},{"path":"https://ideea-model.github.io/IDEEA/articles/reports.html","id":"emissions","dir":"Articles","previous_headings":"Analysis of the model output > Compare the results","what":"Emissions","title":"Reports","text":"","code":"all_emis |>   group_by(scenario, comm, year) |>   summarise(Mt = sum(value) / 1e3, .groups = \"drop\") |>   pivot_wider(names_from = scenario, values_from = Mt) |>   kableExtra::kable(     # caption = \"Emissions from fuel combustion and processes, CO2 Mt, kt others\",      align = \"c\"   )"},{"path":"https://ideea-model.github.io/IDEEA/articles/transmission.html","id":"region-model","dir":"Articles","previous_headings":"","what":"5-region model","title":"Transmission network","text":"","code":"regN <- \"reg5\"  ideea_r5_sf <- get_ideea_map(nreg = 5, islands = FALSE, offshore = FALSE)  transmission_lines <- ideea_data$transmission[[regN]]   # filter(region.x != region.y)   # filter(case == transmission_matrix, !is.na(MW)) |>   # filter(MW >= 0)  gis_mainland_sf <- filter(ideea_r5_sf, offshore == F) points_coord_r5 <- st_centroid(gis_mainland_sf) |>   st_coordinates() |>   as.data.frame() |>   cbind(data.frame(region = gis_mainland_sf[[regN]])) |>   rename(lon = X, lat = Y)  network_r5 <- transmission_lines |>   # filter(case == \"current\") |>   left_join(points_coord_r5, by = c(\"region.x\" = \"region\")) |>   left_join(points_coord_r5, by = c(\"region.y\" = \"region\")) |>   mutate(GW = MW / 1000) |>   rowwise() |>   mutate(     # rough estimate of transmission lines distance between two nodes     distance_km = st_distance(       # length in meters       st_sfc(st_point(c(lon.x, lat.x)), crs = 4326),       st_sfc(st_point(c(lon.y, lat.y)), crs = 4326)       ),     # adding 15% to the distance for landscape     distance_km = round(1.15 * as.numeric(distance_km) / 1e3),     AC_eff = 1 / (1 + 0.1 * distance_km / 1e3), # ~10% loss per 1000 km      AC_invcost = 2 * distance_km, # ~ 2 cr.INR/GW/km     DC_eff = 1 / (1 + 0.02 * distance_km / 1e3), # ~2% loss per 1000 km     DC_invcost = 4 * distance_km # ~ 4 cr.INR/GW/km + converters   ) |>   # add names for transmission lines   mutate(     trd_name_ac = paste(\"HVAC\", region.x, region.y, sep = \"_\"),     trd_name_dc = paste(\"HVDC\", region.x, region.y, sep = \"_\")     ) |>   as.data.table()  # create plot for each case plot_ntw_r5 <- ggplot() +   geom_sf(data = ideea_r5_sf, fill = \"wheat\") +   geom_segment(     aes(       x = lon.x, y = lat.x, xend = lon.y, yend = lat.y,       linewidth = GW     ),     color = \"dodgerblue\", lineend = \"round\",     data = network_r5     # data = filter(a, case %in% transmission_matrix)   ) +   # geom_segment(aes(x = lon.x, y = lat.x, xend = lon.y, yend = lat.y),   #   color = alpha(\"white\", .5), lineend = \"round\",   #   data = filter(a, case == \"new\")   # ) +   facet_wrap(~case) +   geom_point(aes(lon, lat), data = points_coord_r5, color = \"red\") +   labs(x = \"\", y = \"\") +   theme_ideea_map()"},{"path":"https://ideea-model.github.io/IDEEA/articles/transmission.html","id":"region-model-1","dir":"Articles","previous_headings":"","what":"32-region model","title":"Transmission network","text":"cost building new lines function distance regions capacity line.","code":"regN <- \"reg32\"  ideea_r32_sf <- get_ideea_map(nreg = 32, islands = FALSE, offshore = FALSE)  transmission_lines <- ideea_data$transmission[[regN]]    # filter(case == transmission_matrix, !is.na(MW)) |>   # filter(MW >= 0)  gis_mainland_sf <- filter(ideea_r32_sf, offshore == F) points_coord_r32 <- st_centroid(gis_mainland_sf) |>   st_coordinates() |>   as.data.frame() |>   cbind(data.frame(region = gis_mainland_sf[[regN]])) |>   rename(lon = X, lat = Y)  network_r32 <- transmission_lines |>   # filter(case == \"current\") |>   left_join(points_coord_r32, by = c(\"region.x\" = \"region\")) |>   left_join(points_coord_r32, by = c(\"region.y\" = \"region\")) |>   mutate(GW = MW / 1000) |>   rowwise() |>   mutate(     # rough estimate of transmission lines distance between two nodes     distance_km = st_distance(       # length in meters       st_sfc(st_point(c(lon.x, lat.x)), crs = 4326),       st_sfc(st_point(c(lon.y, lat.y)), crs = 4326)       ),     # adding 15% to the distance for landscape     distance_km = round(1.15 * as.numeric(distance_km) / 1e3),     AC_eff = 1 / (1 + 0.1 * distance_km / 1e3), # ~10% loss per 1000 km      AC_invcost = 2 * distance_km, # ~ 2 cr.INR/GW/km     DC_eff = 1 / (1 + 0.02 * distance_km / 1e3), # ~2% loss per 1000 km     DC_invcost = 4 * distance_km # ~ 4 cr.INR/GW/km + converters   ) |>   # add names for transmission lines   mutate(     trd_name_ac = paste(\"HVAC\", region.x, region.y, sep = \"_\"),     trd_name_dc = paste(\"HVDC\", region.x, region.y, sep = \"_\")     ) |>   as.data.table()  # create plot for each case plot_ntw_r32 <- ggplot() +   geom_sf(data = ideea_r32_sf, fill = \"wheat\") +   geom_segment(     aes(       x = lon.x, y = lat.x, xend = lon.y, yend = lat.y       # linewidth = GW     ),     linewidth = 1,     color = \"dodgerblue\", lineend = \"round\",     data = network_r32   ) +   facet_wrap(~case) +   geom_point(aes(lon, lat), data = points_coord_r32, color = \"red\") +   labs(x = \"\", y = \"\") +   theme_ideea_map()"},{"path":[]},{"path":[]},{"path":"https://ideea-model.github.io/IDEEA/articles/transport.html","id":"light-duty-vehicles-ldv","dir":"Articles","previous_headings":"","what":"Light Duty Vehicles (LDV)","title":"IDEEA: transportation module","text":"LDV cars modeled deliver two types transportation services, based efficiency/fuel consumption per trip: * highway passengerkm (P-LDV-HWY) city passenger*km (P-LDV-CTY)","code":""},{"path":"https://ideea-model.github.io/IDEEA/articles/transport.html","id":"commodities","dir":"Articles","previous_headings":"Light Duty Vehicles (LDV)","what":"Commodities","title":"IDEEA: transportation module","text":"","code":"GSL <- newCommodity(   name = \"GSL\",    unit = \"PJ\",    timeframe = \"ANNUAL\")"},{"path":"https://ideea-model.github.io/IDEEA/articles/transport.html","id":"transport-services","dir":"Articles","previous_headings":"Light Duty Vehicles (LDV)","what":"Transport services","title":"IDEEA: transportation module","text":"","code":"PLDVHWY <- newCommodity(   name = \"PLDVHWY\",    desc = \"LDV passengers transportation on highway\",   unit = \"MPKm\", # \"million passenger * km\",    timeframe = \"YDAY\")  PLDVCTY <- newCommodity(   name = \"PLDVCTY\",    desc = \"LDV passengers transportation in city\",   unit = \"MPKm\", # \"million passenger * km\",    timeframe = \"YDAY\")"},{"path":"https://ideea-model.github.io/IDEEA/articles/transport.html","id":"infrastructure","dir":"Articles","previous_headings":"Light Duty Vehicles (LDV)","what":"Infrastructure","title":"IDEEA: transportation module","text":"","code":"GSTATION <- newCommodity(   name = \"GSTATION\",    desc = \"Gas station\",   unit = \"PJ\", # number of cars to fuel a year   timeframe = \"ANNUAL\")  CHARGEST <- newCommodity(   name = \"CHARGEST\",    desc = \"Electric car charing station\",   unit = \"GWh\", # number of cars to fuel a year   timeframe = \"ANNUAL\")"},{"path":"https://ideea-model.github.io/IDEEA/articles/transport.html","id":"gasoline-cars","dir":"Articles","previous_headings":"Light Duty Vehicles (LDV)","what":"Gasoline cars","title":"IDEEA: transportation module","text":"","code":"# Technologies LDVG <- newTechnology(   name = \"LDVG\",   desc = \"Gasoline Light Duty Vehicles\",   input = data.frame(     comm = c(\"GSL\", \"BIO\"),     unit = \"PJ\", # for simplicity and electrification scenarios, normally \"PJ\"     group = \"i\"   ),   output = data.frame(     comm = c(\"PLDVHWY\",  # passenger * km, highway              \"PLDVCTY\"), # passenger * km, city     unit = \"MPKm\", # million passenger * km     group = \"o\" # a number or string, \"o\" = output   ),   units = list(     capacity = \"1000 Vehicles\",     activity = \"million km, city\", # measured in one of the output commodities     costs = \"MUSD\"   ),   cap2act = 10, # 10000 km per car a year => 10000 * 1000 / 1e6   ceff = data.frame(     comm = c(\"GSL\", \"BIO\", \"PLDVHWY\", \"PLDVCTY\"),     use2cact = c(NA, NA, 3, 2), # !!! calculate million km per unit of input     share.up = c(NA, .1, .4, .8),     cact2cout = c(NA, NA, 2, 3) # passengers per vehicles (assumption)   ),   olife = list(olife = 10),   capacity = list(     region = NA,     year = 2022,     stock = 500   ),   invcost = list(     invcost = 15 # 15000 [USD/car] * 1000 [cars] / 1e6 => MUSD/1000 cars   ),   fixom = list(     fixom = .5 # repairs a year, taxes and fees, tires, oil change, parking etc.   ),   # varom = list(   #   varom = ... # could be \"tires, oil change\"    # )   aux = list(     acomm = c(\"GSTATION\", \"PM\"),      unit = c(\"PJ\", \"kt\")   ), # N cars fueled a year   aeff = list(     acomm = c(\"GSTATION\", \"PM\"),     cap2ainp = c(1, NA), # estimate number of trips to gas-station a year     act2aout = c(NA, .01) # find emissions data per km     )   )    draw(LDVG)"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://ideea-model.github.io/IDEEA/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"IDEEA comunity. Author, maintainer.","code":""},{"path":"https://ideea-model.github.io/IDEEA/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"comunity (2024). IDEEA: Indian Zero Carbon Energy Pathways (IDEEA) optimization model. R package version 0.50.0, https://ideea-model.github.io/IDEEA.","code":"@Manual{,   title = {IDEEA: Indian Zero Carbon Energy Pathways (IDEEA) optimization model},   author = {IDEEA comunity},   year = {2024},   note = {R package version 0.50.0},   url = {https://ideea-model.github.io/IDEEA}, }"},{"path":[]},{"path":"https://ideea-model.github.io/IDEEA/code_of_conduct.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://ideea-model.github.io/IDEEA/code_of_conduct.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://ideea-model.github.io/IDEEA/code_of_conduct.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://ideea-model.github.io/IDEEA/code_of_conduct.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official email address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://ideea-model.github.io/IDEEA/code_of_conduct.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement [INSERT CONTACT METHOD]. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://ideea-model.github.io/IDEEA/code_of_conduct.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://ideea-model.github.io/IDEEA/code_of_conduct.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://ideea-model.github.io/IDEEA/code_of_conduct.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://ideea-model.github.io/IDEEA/code_of_conduct.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://ideea-model.github.io/IDEEA/code_of_conduct.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://ideea-model.github.io/IDEEA/code_of_conduct.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired Mozilla’s code conduct enforcement ladder. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://ideea-model.github.io/IDEEA/index.html","id":"indian-zero-carbon-energy-pathways-optimization-model-","dir":"","previous_headings":"","what":"Indian Zero Carbon Energy Pathways (IDEEA) optimization model","title":"Indian Zero Carbon Energy Pathways (IDEEA) optimization model","text":"Indian Zero Carbon Energy Pathways (IDEEA) collaborative open energy modeling initiative Environmental Defense Fund, Global Change Programme, Jadavpur University, Indian Institute Science, Energy Transition Group develop tools scenarios India’s energy transition. project aims evaluation broad set scenarios high penetration variable renewables identify set cost-efficient options deep decarbonization carbon neutrality India broad public discussion.","code":""},{"path":"https://ideea-model.github.io/IDEEA/index.html","id":"ideea-models","dir":"","previous_headings":"","what":"IDEEA models","title":"Indian Zero Carbon Energy Pathways (IDEEA) optimization model","text":"Decarbonization electricity critical milestone energy transition low/zero emissions. Wind solar energy sustainable options decarbonization, recent reduction costs makes first options consider. However, variability energy sources requires explicit modeling evaluation alternative balancing options, hydro energy, energy storage, grid, back-capacity, responsive demand. IDEEA project aims develop “new” “renewables era” modeling framework India evaluate high-VER scenarios based high temporal spatial resolution.","code":""},{"path":"https://ideea-model.github.io/IDEEA/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Indian Zero Carbon Energy Pathways (IDEEA) optimization model","text":"Please refer step--step installation guide “Installation” article. package can installed GitHub using pak package:","code":"# install.packages(\"pak\") pak::pkg_install(\"ideea-model/IDEEA\")  library(\"IDEEA\")"},{"path":"https://ideea-model.github.io/IDEEA/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Indian Zero Carbon Energy Pathways (IDEEA) optimization model","text":"quick example please check Get started page IDEEA R-package documentation page (work progress). examples uploaded ideea-model/ideea_example_project repository.","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU Affero General Public License","title":"GNU Affero General Public License","text":"Version 3, 19 November 2007 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU Affero General Public License","text":"GNU Affero General Public License free, copyleft license software kinds works, specifically designed ensure cooperation community case network server software. licenses software practical works designed take away freedom share change works. contrast, General Public Licenses intended guarantee freedom share change versions program–make sure remains free software users. speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. Developers use General Public Licenses protect rights two steps: (1) assert copyright software, (2) offer License gives legal permission copy, distribute /modify software. secondary benefit defending users’ freedom improvements made alternate versions program, receive widespread use, become available developers incorporate. Many developers free software heartened encouraged resulting cooperation. However, case software used network servers, result may fail come . GNU General Public License permits making modified version letting public access server without ever releasing source code public. GNU Affero General Public License designed specifically ensure , cases, modified source code becomes available community. requires operator network server provide source code modified version running users server. Therefore, public use modified version, publicly accessible server, gives public access source code modified version. older license, called Affero General Public License published Affero, designed accomplish similar goals. different license, version Affero GPL, Affero released new version Affero GPL permits relicensing license. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions.","title":"GNU Affero General Public License","text":"“License” refers version 3 GNU Affero General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code.","title":"GNU Affero General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions.","title":"GNU Affero General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law.","title":"GNU Affero General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies.","title":"GNU Affero General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions.","title":"GNU Affero General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: work must carry prominent notices stating modified , giving relevant date. work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms.","title":"GNU Affero General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms.","title":"GNU Affero General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: Disclaiming warranty limiting liability differently terms sections 15 16 License; Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; Limiting use publicity purposes names licensors authors material; Declining grant rights trademark law use trade names, trademarks, service marks; Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination.","title":"GNU Affero General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies.","title":"GNU Affero General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients.","title":"GNU Affero General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents.","title":"GNU Affero General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom.","title":"GNU Affero General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"id_13-remote-network-interaction-use-with-the-gnu-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Remote Network Interaction; Use with the GNU General Public License.","title":"GNU Affero General Public License","text":"Notwithstanding provision License, modify Program, modified version must prominently offer users interacting remotely computer network (version supports interaction) opportunity receive Corresponding Source version providing access Corresponding Source network server charge, standard customary means facilitating copying software. Corresponding Source shall include Corresponding Source work covered version 3 GNU General Public License incorporated pursuant following paragraph. Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU General Public License single combined work, convey resulting work. terms License continue apply part covered work, work combined remain governed version 3 GNU General Public License.","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License.","title":"GNU Affero General Public License","text":"Free Software Foundation may publish revised /new versions GNU Affero General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU Affero General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU Affero General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU Affero General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty.","title":"GNU Affero General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability.","title":"GNU Affero General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16.","title":"GNU Affero General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://ideea-model.github.io/IDEEA/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU Affero General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. software can interact users remotely computer network, also make sure provides way users get source. example, program web application, interface display “Source” link leads users archive code. many ways offer source, different solutions better different programs; see section 13 specific requirements. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU AGPL, see https://www.gnu.org/licenses/.","code":"<one line to give the program's name and a brief idea of what it does.>     Copyright (C) <year>  <name of author>      This program is free software: you can redistribute it and/or modify     it under the terms of the GNU Affero General Public License as     published by the Free Software Foundation, either version 3 of the     License, or (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU Affero General Public License for more details.      You should have received a copy of the GNU Affero General Public License     along with this program.  If not, see <https://www.gnu.org/licenses/>."},{"path":"https://ideea-model.github.io/IDEEA/reference/add_reg_off.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a column with names of offshore regions — add_reg_off","title":"Add a column with names of offshore regions — add_reg_off","text":"Add column names offshore regions","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/add_reg_off.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a column with names of offshore regions — add_reg_off","text":"","code":"add_reg_off(x, regN, regN_off = paste0(regN, \"_off\"), offshore = \"offshore\")"},{"path":"https://ideea-model.github.io/IDEEA/reference/add_reg_off.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a column with names of offshore regions — add_reg_off","text":"x data frame required two columns: offshore regN regN character name column region names regN_off character name column offshore region names, added data frame, default {regN}_off offshore character name column offshore indicator, default 'offshore'","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/add_reg_off.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a column with names of offshore regions — add_reg_off","text":"data frame added column regN_off","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/add_tech_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Add 'tech_type' column to a data.frame — add_tech_type","title":"Add 'tech_type' column to a data.frame — add_tech_type","text":"Add 'tech_type' column data.frame","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/add_tech_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add 'tech_type' column to a data.frame — add_tech_type","text":"","code":"add_tech_type(x, factors = TRUE, force = TRUE)"},{"path":"https://ideea-model.github.io/IDEEA/reference/add_tech_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add 'tech_type' column to a data.frame — add_tech_type","text":"x data.frame 'process' column factors logical, TRUE, 'tech_type' column class force logical, TRUE add unknown types technologies factor level, report 'unknown types' error FALSE.","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/add_tech_type.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add 'tech_type' column to a data.frame — add_tech_type","text":"x data.frame added overwritten 'tech_type' column.","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/drop_cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Drop cluster identifier from a name — drop_cluster","title":"Drop cluster identifier from a name — drop_cluster","text":"Drop cluster identifier name","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/drop_cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Drop cluster identifier from a name — drop_cluster","text":"","code":"drop_cluster(name, digits = 2, cluster_flag = \"CL\")"},{"path":"https://ideea-model.github.io/IDEEA/reference/drop_cluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Drop cluster identifier from a name — drop_cluster","text":"cluster_flag","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/drop_process_cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Drop cluster identifier from a process name — drop_process_cluster","title":"Drop cluster identifier from a process name — drop_process_cluster","text":"Drop cluster identifier process name","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/drop_process_cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Drop cluster identifier from a process name — drop_process_cluster","text":"","code":"drop_process_cluster(x, digits = 2, cluster_flag = \"CL\")"},{"path":"https://ideea-model.github.io/IDEEA/reference/drop_process_vintage.html","id":null,"dir":"Reference","previous_headings":"","what":"Drop the numeric part of a names in process column of a data frame — drop_process_vintage","title":"Drop the numeric part of a names in process column of a data frame — drop_process_vintage","text":"Drop numeric part names process column data frame","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/drop_process_vintage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Drop the numeric part of a names in process column of a data frame — drop_process_vintage","text":"","code":"drop_process_vintage(x)"},{"path":"https://ideea-model.github.io/IDEEA/reference/drop_process_vintage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Drop the numeric part of a names in process column of a data frame — drop_process_vintage","text":"x","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/drop_process_vintage.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Drop the numeric part of a names in process column of a data frame — drop_process_vintage","text":"","code":"dat <- data.frame(scenario = \"BASE\", process = names(ideea_techs$ENUC)) #> Error in eval(expr, envir, enclos): object 'ideea_techs' not found dat #> Error in eval(expr, envir, enclos): object 'dat' not found dat |> drop_process_vintage() #> Error in eval(expr, envir, enclos): object 'dat' not found"},{"path":"https://ideea-model.github.io/IDEEA/reference/drop_vintage.html","id":null,"dir":"Reference","previous_headings":"","what":"Drop the numeric part of a string (aka vintage in names of technologies) — drop_vintage","title":"Drop the numeric part of a string (aka vintage in names of technologies) — drop_vintage","text":"Drop numeric part string (aka vintage names technologies)","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/drop_vintage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Drop the numeric part of a string (aka vintage in names of technologies) — drop_vintage","text":"","code":"drop_vintage(x)"},{"path":"https://ideea-model.github.io/IDEEA/reference/drop_vintage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Drop the numeric part of a string (aka vintage in names of technologies) — drop_vintage","text":"x character vector","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/drop_vintage.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Drop the numeric part of a string (aka vintage in names of technologies) — drop_vintage","text":"","code":"names(ideea_techs$ECOASUB) #> Error in eval(expr, envir, enclos): object 'ideea_techs' not found drop_vintage(names(ideea_techs$ECOASUB)) #> Error in eval(expr, envir, enclos): object 'ideea_techs' not found"},{"path":"https://ideea-model.github.io/IDEEA/reference/get_cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract cluster string or number from a name — get_cluster","title":"Extract cluster string or number from a name — get_cluster","text":"Extract cluster string number name","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/get_cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract cluster string or number from a name — get_cluster","text":"","code":"get_cluster(name, digits = 2, cluster_flag = \"CL\")"},{"path":"https://ideea-model.github.io/IDEEA/reference/get_cluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract cluster string or number from a name — get_cluster","text":"cluster_flag","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_cf.html","id":null,"dir":"Reference","previous_headings":"","what":"Solar and wind capacity factors by year, region and cluster — get_ideea_cf","title":"Solar and wind capacity factors by year, region and cluster — get_ideea_cf","text":"Solar wind capacity factors year, region cluster","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_cf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solar and wind capacity factors by year, region and cluster — get_ideea_cf","text":"","code":"get_ideea_cf(   resource = \"sol\",   nreg = 5,   year = 2019,   tol = 0.05,   data = \"merra2\",   data_file = \"merra_raw_{year}.fst\",   clusters_file = \"locid_{resource}_cl_r{nreg}.RData\",   tsl_format = \"d365_h24\",   load_from_extra = TRUE,   save_to_extra = TRUE,   overwrite = FALSE )"},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_cf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solar and wind capacity factors by year, region and cluster — get_ideea_cf","text":"resource character, name resource: \"sol\" \"win\" nreg integer, number regions year integer, year data return tol numeric, tolerance information loss clustering 0 1. 0 number clusters equal number locations MERRA2 database. tol 1, one cluster per region. data character, name data source, directory ideea_extra directory. Currently \"merra2\" supported. data_file character, name file raw data data sub-directory ideea_extra. Default \"merra_raw_year.fst\", valid MERRA2 data. clusters_file character, name file clusters data directory. Default \"locid_resource_cl_rnreg.RData\", available ideea_data. tsl_format character, format time-slices. Default \"d365_h24\". changed, clustering done based new time-slices. load_from_extra logical, TRUE, function try read capacity factors file data sub-directory ideea_extra. file requested parameters exists, read. file exist, function calculate capacity factors. Default TRUE. save_to_extra logical, TRUE, function save estimated capacity factors file data sub-directory ideea_extra. Default TRUE. overwrite logical, TRUE, function overwrite existing file capacity factors. Default FALSE.","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_cf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solar and wind capacity factors by year, region and cluster — get_ideea_cf","text":"data.table, capacity factors requested year region, cluster, time-slice. data.table contains following columns: locid - location ID MERRA2 database, year - year data, slice - time-slice, cluster - cluster ID, reg{nreg} reg{nreg}_off - region ID offshore region ID, wcf_* scf_* - capacity factor wind solar resource given height tracking type.","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_cf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solar and wind capacity factors by year, region and cluster — get_ideea_cf","text":"","code":"# don't run # default tolerance level (0.05) get_ideea_cf(resource = \"sol\", nreg = 5, year = 2019) #> Reading capacity factors data from: #>    D:/Dropbox/projects/ideea_extra//merra2/cf_sol_r5_TOL05_d365_h24_2019.fst  #>    Maximum number of clusters per region: 3  #>          year    slice   reg5  reg5_off cluster scf_fh scf_fl scf_tl scf_td #>         <num>   <char> <char>    <char>   <int>  <num>  <num>  <num>  <num> #>      1:  2019 d001_h00   EAST      EAST       1      0      0      0      0 #>      2:  2019 d001_h00   EAST  EAST_off       1      0      0      0      0 #>      3:  2019 d001_h00   EAST  EAST_off       2      0      0      0      0 #>      4:  2019 d001_h00  NORTH     NORTH       1      0      0      0      0 #>      5:  2019 d001_h00  NORTH     NORTH       2      0      0      0      0 #>     ---                                                                     #> 105116:  2019 d365_h23  SOUTH     SOUTH       1      0      0      0      0 #> 105117:  2019 d365_h23  SOUTH SOUTH_off       1      0      0      0      0 #> 105118:  2019 d365_h23  SOUTH SOUTH_off       2      0      0      0      0 #> 105119:  2019 d365_h23   WEST      WEST       1      0      0      0      0 #> 105120:  2019 d365_h23   WEST  WEST_off       1      0      0      0      0 get_ideea_cf(resource = \"sol\", nreg = 32, year = 2019) #> Reading capacity factors data from: #>    D:/Dropbox/projects/ideea_extra//merra2/cf_sol_r32_TOL05_d365_h24_2019.fst  #>    Maximum number of clusters per region: 2  #>          year    slice  reg32 reg32_off cluster scf_fh scf_fl scf_tl scf_td #>         <num>   <char> <char>    <char>   <int>  <num>  <num>  <num>  <num> #>      1:  2019 d001_h00     AN        AN       1      0      0      0      0 #>      2:  2019 d001_h00     AN    AN_off       1      0      0      0      0 #>      3:  2019 d001_h00    APY       APY       1      0      0      0      0 #>      4:  2019 d001_h00    APY   APY_off       1      0      0      0      0 #>      5:  2019 d001_h00     AR        AR       1      0      0      0      0 #>     ---                                                                     #> 385436:  2019 d365_h23     TR        TR       1      0      0      0      0 #> 385437:  2019 d365_h23     UP        UP       1      0      0      0      0 #> 385438:  2019 d365_h23     UT        UT       1      0      0      0      0 #> 385439:  2019 d365_h23     WB        WB       1      0      0      0      0 #> 385440:  2019 d365_h23     WB    WB_off       1      0      0      0      0  get_ideea_cf(resource = \"win\", nreg = 5, year = 2019) #> Reading capacity factors data from: #>    D:/Dropbox/projects/ideea_extra//merra2/cf_win_r5_TOL05_d365_h24_2019.fst  #>    Maximum number of clusters per region: 40  #>          year    slice   reg5 reg5_off cluster wcf_50m wcf_100m wcf_150m #>         <num>   <char> <char>   <char>   <int>   <num>    <num>    <num> #>      1:  2019 d001_h00   EAST     EAST       1   0.057    0.068    0.074 #>      2:  2019 d001_h00   EAST     EAST       2   0.006    0.017    0.026 #>      3:  2019 d001_h00   EAST     EAST       3   0.001    0.003    0.006 #>      4:  2019 d001_h00   EAST     EAST       4   0.063    0.115    0.159 #>      5:  2019 d001_h00   EAST     EAST       5   0.073    0.207    0.346 #>     ---                                                                  #> 981116:  2019 d365_h23   WEST WEST_off       2   0.107    0.120    0.128 #> 981117:  2019 d365_h23   WEST WEST_off       3   0.034    0.040    0.043 #> 981118:  2019 d365_h23   WEST WEST_off       4   0.163    0.187    0.203 #> 981119:  2019 d365_h23   WEST WEST_off       5   0.154    0.223    0.272 #> 981120:  2019 d365_h23   WEST WEST_off       6   0.230    0.282    0.317 get_ideea_cf(resource = \"win\", nreg = 32, year = 2019) #> Reading capacity factors data from: #>    D:/Dropbox/projects/ideea_extra//merra2/cf_win_r32_TOL05_d365_h24_2019.fst  #>    Maximum number of clusters per region: 12  #>           year    slice  reg32 reg32_off cluster wcf_50m wcf_100m wcf_150m #>          <num>   <char> <char>    <char>   <int>   <num>    <num>    <num> #>       1:  2019 d001_h00     AN        AN       1   0.051    0.058    0.062 #>       2:  2019 d001_h00     AN        AN       2   0.058    0.070    0.077 #>       3:  2019 d001_h00     AN    AN_off       1   0.045    0.052    0.056 #>       4:  2019 d001_h00     AN    AN_off       2   0.075    0.085    0.091 #>       5:  2019 d001_h00     AN    AN_off       3   0.050    0.056    0.061 #>      ---                                                                   #> 1086236:  2019 d365_h23    TNY   TNY_off       7   0.241    0.280    0.305 #> 1086237:  2019 d365_h23     UP        UP       1   0.037    0.096    0.155 #> 1086238:  2019 d365_h23     UP        UP       2   0.000    0.000    0.000 #> 1086239:  2019 d365_h23     WB        WB       1   0.017    0.040    0.057 #> 1086240:  2019 d365_h23     WB    WB_off       1   0.013    0.016    0.018  # custom tolerance level (0.01) get_ideea_cf(resource = \"sol\", nreg = 5, tol = 0.01, year = 2019) #> Reading capacity factors data from: #>    D:/Dropbox/projects/ideea_extra//merra2/cf_sol_r5_TOL01_d365_h24_2019.fst  #>    Maximum number of clusters per region: 50  #>           year    slice   reg5 reg5_off cluster scf_fh scf_fl scf_tl scf_td #>          <num>   <char> <char>   <char>   <int>  <num>  <num>  <num>  <num> #>       1:  2019 d001_h00   EAST     EAST       1      0      0      0      0 #>       2:  2019 d001_h00   EAST     EAST       2      0      0      0      0 #>       3:  2019 d001_h00   EAST     EAST       3      0      0      0      0 #>       4:  2019 d001_h00   EAST     EAST       4      0      0      0      0 #>       5:  2019 d001_h00   EAST     EAST       5      0      0      0      0 #>      ---                                                                    #> 1839596:  2019 d365_h23   WEST WEST_off       7      0      0      0      0 #> 1839597:  2019 d365_h23   WEST WEST_off       8      0      0      0      0 #> 1839598:  2019 d365_h23   WEST WEST_off       9      0      0      0      0 #> 1839599:  2019 d365_h23   WEST WEST_off      10      0      0      0      0 #> 1839600:  2019 d365_h23   WEST WEST_off      11      0      0      0      0 get_ideea_cf(resource = \"sol\", nreg = 32, tol = 0.01, year = 2019) #> Reading capacity factors data from: #>    D:/Dropbox/projects/ideea_extra//merra2/cf_sol_r32_TOL01_d365_h24_2019.fst  #>    Maximum number of clusters per region: 18  #>           year    slice  reg32 reg32_off cluster scf_fh scf_fl scf_tl scf_td #>          <num>   <char> <char>    <char>   <int>  <num>  <num>  <num>  <num> #>       1:  2019 d001_h00     AN        AN       1      0      0      0      0 #>       2:  2019 d001_h00     AN        AN       2      0      0      0      0 #>       3:  2019 d001_h00     AN        AN       3      0      0      0      0 #>       4:  2019 d001_h00     AN    AN_off       1      0      0      0      0 #>       5:  2019 d001_h00     AN    AN_off       2      0      0      0      0 #>      ---                                                                     #> 2154956:  2019 d365_h23     WB        WB       2      0      0      0      0 #> 2154957:  2019 d365_h23     WB        WB       3      0      0      0      0 #> 2154958:  2019 d365_h23     WB        WB       4      0      0      0      0 #> 2154959:  2019 d365_h23     WB        WB       5      0      0      0      0 #> 2154960:  2019 d365_h23     WB    WB_off       1      0      0      0      0  get_ideea_cf(resource = \"win\", nreg = 5, tol = 0.01, year = 2019) #> Reading capacity factors data from: #>    D:/Dropbox/projects/ideea_extra//merra2/cf_win_r5_TOL01_d365_h24_2019.fst  #>    Maximum number of clusters per region: 150  #>           year    slice   reg5 reg5_off cluster wcf_50m wcf_100m wcf_150m #>          <num>   <char> <char>   <char>   <int>   <num>    <num>    <num> #>       1:  2019 d001_h00   EAST     EAST       1   0.051    0.058    0.062 #>       2:  2019 d001_h00   EAST     EAST       2   0.070    0.084    0.093 #>       3:  2019 d001_h00   EAST     EAST       3   0.005    0.007    0.008 #>       4:  2019 d001_h00   EAST     EAST       4   0.001    0.004    0.005 #>       5:  2019 d001_h00   EAST     EAST       5   0.003    0.014    0.030 #>      ---                                                                  #> 5352356:  2019 d365_h23   WEST WEST_off      71   0.337    0.381    0.411 #> 5352357:  2019 d365_h23   WEST WEST_off      72   0.349    0.429    0.479 #> 5352358:  2019 d365_h23   WEST WEST_off      73   0.362    0.683    0.874 #> 5352359:  2019 d365_h23   WEST WEST_off      74   0.456    0.846    0.975 #> 5352360:  2019 d365_h23   WEST WEST_off      75   0.440    0.880    0.989 get_ideea_cf(resource = \"win\", nreg = 32, tol = 0.01, year = 2019) #> Reading capacity factors data from: #>    D:/Dropbox/projects/ideea_extra//merra2/cf_win_r32_TOL01_d365_h24_2019.fst  #>    Maximum number of clusters per region: 75  #>           year    slice  reg32 reg32_off cluster wcf_50m wcf_100m wcf_150m #>          <num>   <char> <char>    <char>   <int>   <num>    <num>    <num> #>       1:  2019 d001_h00     AN        AN       1   0.051    0.058    0.062 #>       2:  2019 d001_h00     AN        AN       2   0.070    0.084    0.093 #>       3:  2019 d001_h00     AN        AN       3   0.005    0.007    0.008 #>       4:  2019 d001_h00     AN    AN_off       1   0.019    0.022    0.023 #>       5:  2019 d001_h00     AN    AN_off       2   0.022    0.027    0.030 #>      ---                                                                   #> 5562596:  2019 d365_h23     WB    WB_off       3   0.010    0.010    0.010 #> 5562597:  2019 d365_h23     WB    WB_off       4   0.012    0.015    0.018 #> 5562598:  2019 d365_h23     WB    WB_off       5   0.016    0.022    0.025 #> 5562599:  2019 d365_h23     WB    WB_off       6   0.009    0.013    0.015 #> 5562600:  2019 d365_h23     WB    WB_off       7   0.022    0.051    0.071"},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_cl_sf.html","id":null,"dir":"Reference","previous_headings":"","what":"Load sf (simple feature) object of solar or wind clusters — get_ideea_cl_sf","title":"Load sf (simple feature) object of solar or wind clusters — get_ideea_cl_sf","text":"Load sf (simple feature) object solar wind clusters","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_cl_sf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load sf (simple feature) object of solar or wind clusters — get_ideea_cl_sf","text":"","code":"get_ideea_cl_sf(   resource = \"sol\",   nreg = 5,   tol = 0.05,   data = \"merra2\",   clusters_sf_file = \"locid_{resource}_cl_r{nreg}_sf.RData\" )"},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_cl_sf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load sf (simple feature) object of solar or wind clusters — get_ideea_cl_sf","text":"resource character, name resource: \"sol\" \"win\" nreg integer, number regions tol numeric, tolerance information loss clustering 0 1. 0 number clusters equal number locations MERRA2 database. tol 1, one cluster per region. data character, name data source, directory ideea_extra directory. Currently \"merra2\" supported. clusters_sf_file character, name file clusters data directory. Default \"locid_resource_cl_rnreg_sf.RData\", available ideea_data.","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_cl_sf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load sf (simple feature) object of solar or wind clusters — get_ideea_cl_sf","text":"sf, simple feature object clusters requested resource.","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_cl_sf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load sf (simple feature) object of solar or wind clusters — get_ideea_cl_sf","text":"","code":"# don't run get_ideea_cl_sf(resource = \"sol\", nreg = 5) #> Error in str_detect(names(x), pattern = \"cf_\"): could not find function \"str_detect\" get_ideea_cl_sf(resource = \"win\", nreg = 32, tol = 0.01) #> Error in str_detect(names(x), pattern = \"cf_\"): could not find function \"str_detect\""},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Get data from IDEEA package embedded dataset — get_ideea_data","title":"Get data from IDEEA package embedded dataset — get_ideea_data","text":"Get data IDEEA package embedded dataset","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get data from IDEEA package embedded dataset — get_ideea_data","text":"","code":"get_ideea_data(   name,   nreg = 5,   variable = \".\",   sets = .ideea_sets_mask,   agg_fun = sum,   raw = FALSE,   offshore = FALSE,   islands = TRUE,   as_DT = TRUE,   drop_na = TRUE,   rename = FALSE,   reg_tbl = ideea_data$reg_tbl,   weight = ifelse(identical(agg_fun, sum), \"km2\", 1) )"},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get data from IDEEA package embedded dataset — get_ideea_data","text":"name character, name data table, one : \"coal\", \"oil\", \"gas\", \"biomass\", \"lignite\", ... nreg integer, number region return variable character, regular expression name variable(s) return. sets character, regular expression identify key-columns datasets, used grouping. default value (IDEEA:::.ideea_sets_pattern) covers sets embedded package data. new datasets added different names sets, default value reviewed. agg_fun character, function aggregate data region, default \"sum\" (volumes), \"mean\" advised costs variable. raw logical, raw table returned, FALSE default offshore logical, data offshore areas returned, FALSE default islands logical, data remote islands returned, FALSE default as_DT logical, results returned data.table format TRUE (default) drop_na logical, NA values dropped data reg_tbl data.frame regional mapping (custom weights regions) weight character name column use disaggregating weights disaggregation data required, example saved data 5 regions, requested data 32 regions. general, recommended disaggregate due strong assumptions. algorithm also used convert data 36 32 regions exact match regions' shapes (see Regions article). default value area region (\"km^2\") agg_fun = sum equal 1 (weights) agg_fun = mean functions.","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get data from IDEEA package embedded dataset — get_ideea_data","text":"returns requested table NULL.","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get data from IDEEA package embedded dataset — get_ideea_data","text":"","code":"get_ideea_data(\"coal\", raw = T) #>      reg36                 name36 mainland offshore   reg1  name1 #>     <char>                 <char>   <lgcl>   <lgcl> <char> <char> #>  1:     AP         Andhra Pradesh     TRUE    FALSE    IND  India #>  2:     AR      Arunachal Pradesh     TRUE    FALSE    IND  India #>  3:     AS                  Assam     TRUE    FALSE    IND  India #>  4:     BR                  Bihar     TRUE    FALSE    IND  India #>  5:     CH             Chandigarh     TRUE    FALSE    IND  India #>  6:     CT           Chhattisgarh     TRUE    FALSE    IND  India #>  7:     DD          Daman and Diu     TRUE    FALSE    IND  India #>  8:     DL                  Delhi     TRUE    FALSE    IND  India #>  9:     DN Dadra and Nagar Haveli     TRUE    FALSE    IND  India #> 10:     GA                    Goa     TRUE    FALSE    IND  India #> 11:     GJ                Gujarat     TRUE    FALSE    IND  India #> 12:     HP       Himachal Pradesh     TRUE    FALSE    IND  India #> 13:     HR                Haryana     TRUE    FALSE    IND  India #> 14:     JH              Jharkhand     TRUE    FALSE    IND  India #> 15:     JK      Jammu and Kashmir     TRUE    FALSE    IND  India #> 16:     KA              Karnataka     TRUE    FALSE    IND  India #> 17:     KL                 Kerala     TRUE    FALSE    IND  India #> 18:     MH            Maharashtra     TRUE    FALSE    IND  India #> 19:     ML              Meghalaya     TRUE    FALSE    IND  India #> 20:     MN                Manipur     TRUE    FALSE    IND  India #> 21:     MP         Madhya Pradesh     TRUE    FALSE    IND  India #> 22:     MZ                Mizoram     TRUE    FALSE    IND  India #> 23:     NL               Nagaland     TRUE    FALSE    IND  India #> 24:     OR                 Odisha     TRUE    FALSE    IND  India #> 25:     PB                 Punjab     TRUE    FALSE    IND  India #> 26:     PY             Puducherry     TRUE    FALSE    IND  India #> 27:     RJ              Rajasthan     TRUE    FALSE    IND  India #> 28:     SK                 Sikkim     TRUE    FALSE    IND  India #> 29:     TG              Telangana     TRUE    FALSE    IND  India #> 30:     TN             Tamil Nadu     TRUE    FALSE    IND  India #> 31:     TR                Tripura     TRUE    FALSE    IND  India #> 32:     UP          Uttar Pradesh     TRUE    FALSE    IND  India #> 33:     UT            Uttarakhand     TRUE    FALSE    IND  India #> 34:     WB            West Bengal     TRUE    FALSE    IND  India #>      reg36                 name36 mainland offshore   reg1  name1 #>     total_reserve_Mt production_2021 cost_USD_t_2020 #>                <num>           <num>           <num> #>  1:          4141.87              NA              50 #>  2:            90.23              NA              50 #>  3:           525.01           0.036              50 #>  4:          4437.18              NA              50 #>  5:               NA              NA              NA #>  6:         74191.76         158.409              50 #>  7:               NA              NA              NA #>  8:               NA              NA              NA #>  9:               NA              NA              NA #> 10:               NA              NA              NA #> 11:               NA              NA              NA #> 12:               NA              NA              NA #> 13:               NA              NA              NA #> 14:         86660.10         119.296              50 #> 15:               NA              NA              NA #> 16:               NA              NA              NA #> 17:               NA              NA              NA #> 18:         13220.71          47.435              50 #> 19:           576.48              NA              50 #> 20:               NA              NA              NA #> 21:         30916.73         132.531              50 #> 22:               NA              NA              NA #> 23:           478.31              NA              50 #> 24:         88104.60         154.150              50 #> 25:               NA              NA              NA #> 26:               NA              NA              NA #> 27:               NA              NA              NA #> 28:           101.23              NA              50 #> 29:         23034.20          52.603              50 #> 30:               NA              NA              NA #> 31:               NA              NA              NA #> 32:          1061.80          17.016              50 #> 33:               NA              NA              NA #> 34:         33871.25          34.596              50 #>     total_reserve_Mt production_2021 cost_USD_t_2020 get_ideea_data(\"coal\", nreg = 7, \"reserve\") #>         reg7 mainland offshore total_reserve_Mt #>       <char>   <lgcl>   <lgcl>            <num> #> 1:      EAST     TRUE    FALSE        213174.36 #> 2:     NORTH     TRUE    FALSE          1061.80 #> 3: NORTHEAST     TRUE    FALSE          1670.03 #> 4:     SOUTH     TRUE    FALSE         27176.07 #> 5:      WEST     TRUE    FALSE        118329.20 get_ideea_data(\"oil\", nreg = 34, \"reserve\", islands = T) #>     reg34 offshore mainland oil_reserve_Mt_2021 oil_reserve_GWh_2021 #>    <char>   <lgcl>   <lgcl>               <num>                <num> #> 1:    APY    FALSE     TRUE                7.33              85247.9 #> 2:     AR    FALSE     TRUE                3.64              42333.2 #> 3:     AS    FALSE     TRUE              153.05            1779971.5 #> 4:    GJD    FALSE     TRUE                2.38              27679.4 #> 5:     NL    FALSE     TRUE               34.77             404375.1 #> 6:     RJ    FALSE     TRUE                9.08             105600.4 #> 7:    TNY    FALSE     TRUE                0.07                814.1 #> 8:     TR    FALSE     TRUE              219.27            2550110.1 get_ideea_data(\"coal\", nreg = 7, \"cost\", agg_fun = mean) #>         reg7 mainland offshore cost_USD_t_2020 #>       <char>   <lgcl>   <lgcl>           <num> #> 1:      EAST     TRUE    FALSE              50 #> 2:     NORTH     TRUE    FALSE              50 #> 3: NORTHEAST     TRUE    FALSE              50 #> 4:     SOUTH     TRUE    FALSE              50 #> 5:      WEST     TRUE    FALSE              50 get_ideea_data(\"merra_raw_2014\", raw = T) |> head() #> Key: <UTC, locid> #>                    UTC  locid  W10M  W50M SWGDN ALBEDO #>                 <POSc>  <int> <num> <num> <int>  <num> #> 1: 2014-01-01 00:30:00 109878   5.6   6.0    63   0.12 #> 2: 2014-01-01 00:30:00 109879   4.4   4.7    71   0.12 #> 3: 2014-01-01 00:30:00 110453   6.7   7.3    53   0.13 #> 4: 2014-01-01 00:30:00 110454   5.6   6.0    61   0.13 #> 5: 2014-01-01 00:30:00 110455   4.2   4.5    51   0.12 #> 6: 2014-01-01 00:30:00 111028   8.9   9.9    19   0.10"},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Get IDEEA map with custom number of regions — get_ideea_map","title":"Get IDEEA map with custom number of regions — get_ideea_map","text":"Get IDEEA map custom number regions","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get IDEEA map with custom number of regions — get_ideea_map","text":"","code":"get_ideea_map(   nreg = 5,   offshore = FALSE,   islands = TRUE,   aggregate = (nreg != 46),   rename = FALSE,   reg_off = offshore,   merge_islands = TRUE,   ... )"},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get IDEEA map with custom number of regions — get_ideea_map","text":"nreg integer, number regions, one 1, 5, 7, 32, 34, 36, 37 46 offshore logical, TRUE, offshore area associated regions returned islands logical, \"Andaman Nicobar\" (\"\") \"Lakshadweep\" (\"LD\") included. aggregate logical, true, geometries aggregated region. rename logical, TRUE, region name returned instead reg{nreg} name{nreg} reg_off logical, TRUE, reg_off reg{nreg}_off column added added _off names offshore areas/regions. merge_islands logical, mainland column dropped (TRUE) added (FALSE) returned sf-object. ...","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get IDEEA map with custom number of regions — get_ideea_map","text":"IDEEA map 'sf' 'sp' format","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/get_ideea_map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get IDEEA map with custom number of regions — get_ideea_map","text":"","code":"library(sf) gis_sf <- get_ideea_map(nreg = 1, offshore = F, islands = T) plot(gis_sf[1], key.width = lcm(4))  gis_sf <- get_ideea_map(nreg = 7, offshore = T, islands = T, reg_off = T) plot(gis_sf[\"region\"], key.width = lcm(4)) #> Error in x[i]: Can't subset columns that don't exist. #> ✖ Column `region` doesn't exist. plot(gis_sf[\"reg_off\"], key.width = lcm(4)) #> Error in x[i]: Can't subset columns that don't exist. #> ✖ Column `reg_off` doesn't exist. gis_sf <- get_ideea_map(nreg = 32, offshore = T, islands = T) plot(gis_sf[1], key.width = lcm(4))"},{"path":"https://ideea-model.github.io/IDEEA/reference/IDEEA-package.html","id":null,"dir":"Reference","previous_headings":"","what":"IDEEA: Indian Zero Carbon Energy Pathways (IDEEA) optimization model — IDEEA-package","title":"IDEEA: Indian Zero Carbon Energy Pathways (IDEEA) optimization model — IDEEA-package","text":"IDEEA capacity expansion energy resource planning model built goal explore energy transition options pathways India, inform policy.","code":""},{"path":[]},{"path":"https://ideea-model.github.io/IDEEA/reference/IDEEA-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"IDEEA: Indian Zero Carbon Energy Pathways (IDEEA) optimization model — IDEEA-package","text":"Maintainer: IDEEA comunity ideea@email.org","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_cl_mask.html","id":null,"dir":"Reference","previous_headings":"","what":"Cluster — ideea_cl_mask","title":"Cluster — ideea_cl_mask","text":"Cluster","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_cl_mask.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cluster — ideea_cl_mask","text":"","code":"ideea_cl_mask(tol, width = 2)"},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_cl_mask.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cluster — ideea_cl_mask","text":"tol","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_data.html","id":null,"dir":"Reference","previous_headings":"","what":"IDEEA datasets — ideea_data","title":"IDEEA datasets — ideea_data","text":"Embedded datasets IDEEA models","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IDEEA datasets — ideea_data","text":"","code":"data(ideea_data)"},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"IDEEA datasets — ideea_data","text":"list data frames: reg_tbl mapping table regions load_2019_MWh load curve region 2019 elc_consumption Historic projected electricity consumption region coal coal domestic resources region lignite lignite domestic resources region oil oil domestic resources gas natural gas domestic resources biomass biomass domestic resources generators installed power plants capacity fuel type region merra_raw_2014 MERRA2 subset 2014","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_extra.html","id":null,"dir":"Reference","previous_headings":"","what":"Return path to the IDEEA extra-data directory — ideea_extra","title":"Return path to the IDEEA extra-data directory — ideea_extra","text":"Return path IDEEA extra-data directory","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_extra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return path to the IDEEA extra-data directory — ideea_extra","text":"","code":"ideea_extra(subdir = NULL, filename = NULL, check = FALSE)"},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_extra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return path to the IDEEA extra-data directory — ideea_extra","text":"subdir character, name path sub-directory IDEEA-extra folder. File name also accepted. path must relative IDEEA external folder. filename character, name file IDEEA-extra folder subfolder subdir provided. check logical, TRUE, function report error directory file exist.","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_extra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return path to the IDEEA extra-data directory — ideea_extra","text":"character, path IDEEA external data directory file.","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_extra.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return path to the IDEEA extra-data directory — ideea_extra","text":"","code":"ideea_extra() #> [1] \"D:/Dropbox/projects/ideea_extra/\" ideea_extra(\"merra\") #> [1] \"D:/Dropbox/projects/ideea_extra//merra\" ideea_extra(\"merra\", \"merra_raw_2019.fst\") #> [1] \"D:/Dropbox/projects/ideea_extra//merra/merra_raw_2019.fst\""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_gif_cf.html","id":null,"dir":"Reference","previous_headings":"","what":"Create GIF animation of capacity factors by cluster and time-slice — ideea_gif_cf","title":"Create GIF animation of capacity factors by cluster and time-slice — ideea_gif_cf","text":"Create GIF animation capacity factors cluster time-slice","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_gif_cf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create GIF animation of capacity factors by cluster and time-slice — ideea_gif_cf","text":"","code":"ideea_gif_cf(   x,   ideea_cl_sf,   ideea_sf = NULL,   cf_name = names(x)[grepl(\"cf_\"), names(x)][1],   slice = unique(x$slice)[1:24],   timestamp.stamp = TRUE,   fill_scale_lims = range(x[[cf_name]]),   fps = 12,   gif.width = 576,   gif.height = 576,   filename = \"ideea_cl.gif\" )"},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_gif_cf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create GIF animation of capacity factors by cluster and time-slice — ideea_gif_cf","text":"x data.frame capacity factors, typically get_ideea_cf() ideea_cl_sf sf, cluster shapefile, typically get_ideea_cl_sf() ideea_sf sf, ideea shapefile, typically get_ideea_map() cf_name character, name capacity factor column x (e.g. \"wcf_100m\", \"scf_tl\", etc.) slice character vector, time-slices udpate GIF timestamp.stamp logical, TRUE, add timestamp plot fill_scale_lims numeric vector length two, limits fill scale fps numeric, frames per second, default 12 gif.width numeric, width GIF, default 576 gif.height numeric, height GIF, default 576 filename character, name GIF file","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_gif_cf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create GIF animation of capacity factors by cluster and time-slice — ideea_gif_cf","text":"GIF animation capacity factors cluster time-slice saved working directory","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_gif_cf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create GIF animation of capacity factors by cluster and time-slice — ideea_gif_cf","text":"","code":"# do not run resource <- \"win\"; cf_name <- \"wcf_100m\" resource <- \"sol\"; cf_name <- \"scf_tl\" nreg <- 5 tol <- 0.01  ideea_sf <- get_ideea_map(nreg = nreg, offshore = T, islands = T) ideea_cl_sf <- get_ideea_cl_sf(resource = resource, tol = tol) #> Error in str_detect(names(x), pattern = \"cf_\"): could not find function \"str_detect\"  ideea_cl_sf$cluster |> unique() #> Error in eval(expr, envir, enclos): object 'ideea_cl_sf' not found plot(ideea_cl_sf[\"cluster\"]) #> Error in eval(expr, envir, enclos): object 'ideea_cl_sf' not found  x <- get_ideea_cf(resource, tol = tol) #> Reading capacity factors data from: #>    D:/Dropbox/projects/ideea_extra//merra2/cf_sol_r5_TOL01_d365_h24_2019.fst  #>    Maximum number of clusters per region: 50   slices_1day_per_month <-   ideea_modules$electricity$reg7_base$partial_calendar_1day_per_month@timetable$slice #> Error in ideea_modules$electricity$reg7_base$partial_calendar_1day_per_month@timetable: no applicable method for `@` applied to an object of class \"NULL\"  ideea_gif_cf(x, ideea_cl_sf, ideea_sf, cf_name = cf_name,              slice = slices_1day_per_month,              filename = glue(\"tmp/{resource}.gif\")) #> Error in eval(expr, envir, enclos): object 'slices_1day_per_month' not found"},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_global_options.html","id":null,"dir":"Reference","previous_headings":"","what":"Save, load, edit, or remove IDEEA global options — ideea_global_options","title":"Save, load, edit, or remove IDEEA global options — ideea_global_options","text":"Save, load, edit, remove IDEEA global options","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_global_options.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save, load, edit, or remove IDEEA global options — ideea_global_options","text":"","code":"ideea_global_options(edit = FALSE, load = !edit, remove = FALSE)"},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_global_options.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save, load, edit, or remove IDEEA global options — ideea_global_options","text":"edit logical, TRUE open file IDE default text editor load logical, TRUE load global options file remove logical, TRUE remove global options file","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_global_options.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save, load, edit, or remove IDEEA global options — ideea_global_options","text":"first run creates file '~/.ideea.R' commented settings opens file editing. second run, sources file load settings. Returns TRUE invisibly successful, FALSE . function called loading IDEEA package sources '~/.ideea.R' file previously created.","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_modules.html","id":null,"dir":"Reference","previous_headings":"","what":"IDEEA model components — ideea_modules","title":"IDEEA model components — ideea_modules","text":"Model modules components","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_modules.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IDEEA model components — ideea_modules","text":"","code":"ideea_modules"},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_modules.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"IDEEA model components — ideea_modules","text":"list data frames: energy Primary energy supply module (see article energy) electricity Electric power sector module","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_options_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary of IDEEA global options — ideea_options_summary","title":"Summary of IDEEA global options — ideea_options_summary","text":"Summary IDEEA global options","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_options_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary of IDEEA global options — ideea_options_summary","text":"","code":"ideea_options_summary()"},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_options_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary of IDEEA global options — ideea_options_summary","text":"list IDEEA global options","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_options_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary of IDEEA global options — ideea_options_summary","text":"","code":"if (FALSE) { # interactive() ideea_options_summary() }"},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_scenarios.html","id":null,"dir":"Reference","previous_headings":"","what":"Get current IDEEA-scenarios directory — ideea_scenarios","title":"Get current IDEEA-scenarios directory — ideea_scenarios","text":"Get current IDEEA-scenarios directory","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_scenarios.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get current IDEEA-scenarios directory — ideea_scenarios","text":"","code":"ideea_scenarios()"},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_scenarios_list.html","id":null,"dir":"Reference","previous_headings":"","what":"List saved scenarios in the IDEEA-scenarios directory — ideea_scenarios_list","title":"List saved scenarios in the IDEEA-scenarios directory — ideea_scenarios_list","text":"List saved scenarios IDEEA-scenarios directory","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_scenarios_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List saved scenarios in the IDEEA-scenarios directory — ideea_scenarios_list","text":"","code":"ideea_scenarios_list()"},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_scenario_dir_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Add model, calendar, and other details to a name IDEEA scenario — ideea_scenario_dir_name","title":"Add model, calendar, and other details to a name IDEEA scenario — ideea_scenario_dir_name","text":"Add model, calendar, details name IDEEA scenario","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_scenario_dir_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add model, calendar, and other details to a name IDEEA scenario — ideea_scenario_dir_name","text":"","code":"ideea_scenario_dir_name(   name,   model_name = NULL,   calendar_name = NULL,   horizon_name = NULL,   suffix = NULL,   sep = \"_\" )"},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_scenario_dir_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add model, calendar, and other details to a name IDEEA scenario — ideea_scenario_dir_name","text":"name character, basic name IDEEA scenario model_name character, model name calendar_name character, calendar name suffix character, additional string add name sep character, separator identifiers, \"_\" default","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_scenario_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Add model, calendar, and other details to a name IDEEA scenario — ideea_scenario_name","title":"Add model, calendar, and other details to a name IDEEA scenario — ideea_scenario_name","text":"Add model, calendar, details name IDEEA scenario","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_scenario_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add model, calendar, and other details to a name IDEEA scenario — ideea_scenario_name","text":"","code":"ideea_scenario_name(   name,   model_name = NULL,   calendar_name = NULL,   horizon_name = NULL,   suffix = NULL,   sep = \"_\" )"},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_scenario_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add model, calendar, and other details to a name IDEEA scenario — ideea_scenario_name","text":"name character, basic name IDEEA scenario model_name character, model name calendar_name character, calendar name suffix character, additional string add name sep character, separator identifiers, \"_\" default","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_snapshot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot or return data for hourly operation of electricity sector — ideea_snapshot","title":"Plot or return data for hourly operation of electricity sector — ideea_snapshot","text":"Plot return data hourly operation electricity sector","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_snapshot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot or return data for hourly operation of electricity sector — ideea_snapshot","text":"","code":"ideea_snapshot(scen, YEAR, SLICE, return_data = FALSE)"},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_snapshot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot or return data for hourly operation of electricity sector — ideea_snapshot","text":"scen solved scenario object YEAR integer vector years return SLICE character vector time-slices return return_data logical, TRUE, data return, gglot object otherwise.","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_snapshot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot or return data for hourly operation of electricity sector — ideea_snapshot","text":"ggplot object data.table data figure.","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_snapshot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot or return data for hourly operation of electricity sector — ideea_snapshot","text":"","code":"# all_slices <- scen_CAP@settings@calendar@timetable$slice # ideea_snapshot(scen_CAP, YEAR = 2055, SLICE = all_slices[grepl(\"d043\", all_slices)]) # ideea_snapshot(scen_CAP, YEAR = 2055, SLICE = all_slices[grepl(\"d015\", all_slices)])"},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_snapshot_cf.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a snapshot of capacity factors by cluster and time-slice — ideea_snapshot_cf","title":"Plot a snapshot of capacity factors by cluster and time-slice — ideea_snapshot_cf","text":"Plot snapshot capacity factors cluster time-slice","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_snapshot_cf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a snapshot of capacity factors by cluster and time-slice — ideea_snapshot_cf","text":"","code":"ideea_snapshot_cf(   x,   ideea_cl_sf,   ideea_sf = NULL,   cf_name = names(x)[grepl(\"cf_\"), names(x)][1],   slice = sample(x$slice, 1),   timestamp.stamp = TRUE,   return_data = FALSE,   fill_scale_lims = range(x[[cf_name]]),   ... )"},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_snapshot_cf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a snapshot of capacity factors by cluster and time-slice — ideea_snapshot_cf","text":"x data.frame, capacity factors data, outpuf get_ideea_cf() ideea_cl_sf sf object, cluster shapefile, output get_ideea_cl_sf() ideea_sf sf object, ideea shapefile, output get_ideea_map() cf_name character, name capacity factor column (e.g. \"wcf_100m\", \"scf_tl\", etc.) slice character length one, time-slice plot (e.g. \"d001_h00\") return_data logical, TRUE, function returns data used plotting fill_scale_lims numeric length two, limits fill scale ... ignored datatime logical, TRUE, time-slice converted timestamp","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_snapshot_cf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a snapshot of capacity factors by cluster and time-slice — ideea_snapshot_cf","text":"ggplot object capacity factors cluster time-slice data used plotting","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/ideea_snapshot_cf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a snapshot of capacity factors by cluster and time-slice — ideea_snapshot_cf","text":"","code":"resource <- \"win\" nreg <- 5 tol <- 0.1 cf_name <- \"wcf_100m\" ideea_sf <- get_ideea_map(nreg = nreg, offshore = T, islands = T) ideea_cl_sf <- get_ideea_cl_sf(resource = resource, tol = tol) #> Error in str_detect(names(x), pattern = \"cf_\"): could not find function \"str_detect\" x <- get_ideea_cf(resource, tol = tol) #> Reading capacity factors data from: #>    D:/Dropbox/projects/ideea_extra//merra2/cf_win_r5_TOL10_d365_h24_2019.fst  #>    Maximum number of clusters per region: 11  ideea_snapshot_cf(x, ideea_cl_sf, ideea_sf, cf_name = cf_name) #> Error in eval(expr, envir, enclos): object 'ideea_cl_sf' not found"},{"path":"https://ideea-model.github.io/IDEEA/reference/name_with_cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine name with cluster number — name_with_cluster","title":"Combine name with cluster number — name_with_cluster","text":"Combine name cluster number","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/name_with_cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine name with cluster number — name_with_cluster","text":"","code":"name_with_cluster(name, cluster, ndigits = 2)"},{"path":"https://ideea-model.github.io/IDEEA/reference/name_with_cluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine name with cluster number — name_with_cluster","text":"ndigits","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://ideea-model.github.io/IDEEA/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/set_ideea_extra.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify directory for IDEEA external dataset (ideea_extra) — set_ideea_extra","title":"Specify directory for IDEEA external dataset (ideea_extra) — set_ideea_extra","text":"Specify directory IDEEA external dataset (ideea_extra)","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/set_ideea_extra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify directory for IDEEA external dataset (ideea_extra) — set_ideea_extra","text":"","code":"set_ideea_extra(path = NULL)"},{"path":"https://ideea-model.github.io/IDEEA/reference/set_ideea_extra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify directory for IDEEA external dataset (ideea_extra) — set_ideea_extra","text":"path character, path dataset","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/set_ideea_extra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify directory for IDEEA external dataset (ideea_extra) — set_ideea_extra","text":"(invisible) logical, TRUE directory set, FALSE otherwise.","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/set_ideea_scenarios.html","id":null,"dir":"Reference","previous_headings":"","what":"Set directory for IDEEA scenarios — set_ideea_scenarios","title":"Set directory for IDEEA scenarios — set_ideea_scenarios","text":"Set directory IDEEA scenarios","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/set_ideea_scenarios.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set directory for IDEEA scenarios — set_ideea_scenarios","text":"","code":"set_ideea_scenarios(path = NULL)"},{"path":"https://ideea-model.github.io/IDEEA/reference/set_ideea_scenarios.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set directory for IDEEA scenarios — set_ideea_scenarios","text":"path character path directory /IDEEA scenarios","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/theme_ideea_map.html","id":null,"dir":"Reference","previous_headings":"","what":"ggplot theme for IDEEA maps — theme_ideea_map","title":"ggplot theme for IDEEA maps — theme_ideea_map","text":"ggplot theme IDEEA maps","code":""},{"path":"https://ideea-model.github.io/IDEEA/reference/theme_ideea_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ggplot theme for IDEEA maps — theme_ideea_map","text":"","code":"theme_ideea_map()"}]
